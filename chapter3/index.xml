<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cycle de vie :: Cours de C++ - Niveau Master</title><link>/chapter3/index.html</link><description>En C++, lorsque vous allouez une donnÃ©e, celle-ci ne reste pas miraculement accessible durant toute lâ€™exÃ©cution de votre programme.
Contrairement Ã  des langages comme Java ou C#, qui disposent dâ€™un garbage-collector pour libÃ©rer automatiquement la mÃ©moire lorsque celle-ci nâ€™est plus nÃ©cessaire, câ€™est ici au dÃ©veloppeur de faire ce travail.
Il doit penser Ã  libÃ©rer la mÃ©moire lorsquâ€™il ne compte plus sâ€™en servir, mais surtout, il doit faire attention Ã  ne pas tenter dâ€™accÃ©der Ã  des donnÃ©es si celles-ci nâ€™existent dÃ©jÃ  plus ğŸ˜¬</description><generator>Hugo</generator><language>fr</language><atom:link href="/chapter3/index.xml" rel="self" type="application/rss+xml"/><item><title>Allocation dynamique ğŸ‡</title><link>/chapter3/1-allocation/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter3/1-allocation/index.html</guid><description>Cette premiÃ¨re page sera assez courte, elle vous prÃ©sentera simplement la syntaxe permettant dâ€™allouer dynamiquement de la mÃ©moire et de la libÃ©rer.
Allouer un seul Ã©lÃ©ment Pour allouer un bloc de mÃ©moire, on utilise le mot-clef new, suivi du type de donnÃ©e que lâ€™on souhaite y placer, puis de la valeur avec laquelle on souhaite lâ€™initialiser.
Cette instruction retourne un pointeur.
int* ptr_5 = new int { 5 }; std::cout &lt;&lt; *ptr_5 &lt;&lt; std::endl; // --> 5 Comme pour une variable classique, on peut utiliser des {} ou des () pour indiquer la valeur initiale.</description></item><item><title>DurÃ©e de vie â³</title><link>/chapter3/2-lifespan/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter3/2-lifespan/index.html</guid><description>Nous allons maintenant revenir sur lâ€™instanciation et la dÃ©sinstanciation des donnÃ©es, car ce sont les deux Ã©vÃ©nements qui dÃ©limitent leur pÃ©riode de validitÃ©.
DonnÃ©e de type fondamental Lâ€™instanciation dâ€™une donnÃ©e de type fondamental est constituÃ© de deux phases.
Le programme alloue lâ€™espace nÃ©cessaire pour stocker la donnÃ©e. Si spÃ©cifiÃ© par le programmeur, le contenu de la donnÃ©e est initialisÃ©. En ce qui concerne la dÃ©sinstanciation, le programme dÃ©salloue lâ€™espace rÃ©servÃ© pour la donnÃ©e.</description></item><item><title>Espace de stockage ğŸ’¾</title><link>/chapter3/3-storage/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter3/3-storage/index.html</guid><description>Sur cette page, nous rappelerons ce que sont les variables et les pointeurs, et comment ils peuvent Ãªtre reprÃ©sentÃ©s en mÃ©moire, puis nous ferons de mÃªme pour les rÃ©fÃ©rences.
Nous prÃ©senterons ensuite les spÃ©cificitÃ©s des trois zones dans lesquelles le programme alloue de la mÃ©moire : la mÃ©moire statique, la pile et le tas.
Cela vous aidera, jâ€™espÃ¨re, Ã  visualiser mentalement quelles sont les donnÃ©es valides du programme.
ReprÃ©sentation Variables Une variable est un identifiant permettant dâ€™accÃ©der Ã  une donnÃ©e de taille fixe en mÃ©moire.</description></item><item><title>Usage des rÃ©fÃ©rences ğŸ”€</title><link>/chapter3/4-references/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter3/4-references/index.html</guid><description>Comme cela doit paraÃ®tre encore un peu abstrait, nous allons vous prÃ©senter concrÃ¨tement les principaux cas dâ€™utilisation des rÃ©fÃ©rences. Notez quâ€™il en existe un autre, mais vous le dÃ©couvrirez dans le chapitre sur lâ€™hÃ©ritage !
Modifier un argument Le premier cas dâ€™utilisation des rÃ©fÃ©rences avait dÃ©jÃ  Ã©tÃ© dÃ©crit dans le Chapitre 1 : il sâ€™agit de pouvoir modifier la valeur ou le contenu dâ€™un argument passÃ© Ã  une fonction.
Pour rappel, lorsque vous passez un objet par valeur en paramÃ¨tre dâ€™une fonction, lâ€™intÃ©gralitÃ© de lâ€™instance est copiÃ©e !</description></item><item><title>Ownership ğŸ˜ï¸</title><link>/chapter3/5-ownership/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter3/5-ownership/index.html</guid><description>Jusquâ€™ici, nous vous avons expliquÃ© que contrairement au Java, les donnÃ©es que vous instanciez ne restent pas magiquement en vie tant que vous en avez besoin.
Câ€™est donc Ã  vous de garantir que vos donnÃ©es ne seront pas dÃ©sinstanciÃ©es avant dâ€™avoir fini de les utiliser.
Sur cette page, nous allons introduire le concept dâ€™ownership, qui vous aidera Ã  mieux architecturer votre code pour Ã©viter de vous retrouver avec des dangling-references.</description></item><item><title>Questionnaire â˜‘</title><link>/chapter3/test/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter3/test/index.html</guid><description>Vous Ãªtes : Votre adresse mail : Votre groupe : Initiaux 1 Initiaux 2 Alternants 1- Quels sont les avantages et les inconvÃ©nients de la pile par rapport du tas ?
2- A quoi sert le mot-clef delete[] ?
3- Quels sont les deux Ã©vÃ©nements qui dÃ©limitent la durÃ©e de vie dâ€™une donnÃ©e ?
4- Quâ€™est-ce quâ€™une dangling-reference ?
Donnez un exemple de situation dans lequel on peut en avoir une.</description></item><item><title>Merci !</title><link>/chapter3/test_done/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter3/test_done/index.html</guid><description>Vos rÃ©ponses nous ont bien Ã©tÃ© communiquÃ©es ğŸ˜ƒ N'hÃ©sitez pas Ã  nous relancer si vous n'avez pas eu de nouvelles aprÃ¨s une semaine !</description></item></channel></rss>