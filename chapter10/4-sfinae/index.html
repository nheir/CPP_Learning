<!doctype html><html lang=fr dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 7.0.1+72a875f1db967152c77914cff4d53f8fcee0e619"><meta name=description content="Nous allons maintenant vous expliquer ce que signifie SFINAE, le besoin auquel ce m√©canisme r√©pond et comment le mettre en oeuvre dans votre code.
Le besoin Supposons que nous souhaitions pouvoir r√©cup√©rer une clef pour diff√©rents type √† l‚Äôaide d‚Äôune fonction get_key(const Type&), en utilisant des overloads.
class Person { public: Person(const std::string& name) : _name { name } {} const std::string& get_name() const { return _name; } private: const std::string _name; }; // Overload pour notre classe Person."><meta name=author content><meta name=twitter:card content="summary"><meta name=twitter:title content="SFINAE :: Cours de C++ - Niveau Master"><meta name=twitter:description content="Nous allons maintenant vous expliquer ce que signifie SFINAE, le besoin auquel ce m√©canisme r√©pond et comment le mettre en oeuvre dans votre code.
Le besoin Supposons que nous souhaitions pouvoir r√©cup√©rer une clef pour diff√©rents type √† l‚Äôaide d‚Äôune fonction get_key(const Type&), en utilisant des overloads.
class Person { public: Person(const std::string& name) : _name { name } {} const std::string& get_name() const { return _name; } private: const std::string _name; }; // Overload pour notre classe Person."><meta property="og:url" content="/chapter10/4-sfinae/index.html"><meta property="og:site_name" content="Cours de C++ - Niveau Master"><meta property="og:title" content="SFINAE :: Cours de C++ - Niveau Master"><meta property="og:description" content="Nous allons maintenant vous expliquer ce que signifie SFINAE, le besoin auquel ce m√©canisme r√©pond et comment le mettre en oeuvre dans votre code.
Le besoin Supposons que nous souhaitions pouvoir r√©cup√©rer une clef pour diff√©rents type √† l‚Äôaide d‚Äôune fonction get_key(const Type&), en utilisant des overloads.
class Person { public: Person(const std::string& name) : _name { name } {} const std::string& get_name() const { return _name; } private: const std::string _name; }; // Overload pour notre classe Person."><meta property="og:locale" content="fr"><meta property="og:type" content="article"><meta property="article:section" content="Param√®tres de templates"><meta itemprop=name content="SFINAE :: Cours de C++ - Niveau Master"><meta itemprop=description content="Nous allons maintenant vous expliquer ce que signifie SFINAE, le besoin auquel ce m√©canisme r√©pond et comment le mettre en oeuvre dans votre code.
Le besoin Supposons que nous souhaitions pouvoir r√©cup√©rer une clef pour diff√©rents type √† l‚Äôaide d‚Äôune fonction get_key(const Type&), en utilisant des overloads.
class Person { public: Person(const std::string& name) : _name { name } {} const std::string& get_name() const { return _name; } private: const std::string _name; }; // Overload pour notre classe Person."><meta itemprop=wordCount content="1573"><title>SFINAE :: Cours de C++ - Niveau Master</title>
<link href=../../css/fontawesome-all.min.css?1729268597 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/fontawesome-all.min.css?1729268597 rel=stylesheet></noscript><link href=../../css/nucleus.css?1729268597 rel=stylesheet><link href=../../css/auto-complete.css?1729268597 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/auto-complete.css?1729268597 rel=stylesheet></noscript><link href=../../css/perfect-scrollbar.min.css?1729268597 rel=stylesheet><link href=../../css/fonts.css?1729268597 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/fonts.css?1729268597 rel=stylesheet></noscript><link href=../../css/theme.css?1729268597 rel=stylesheet><link href=../../css/theme-mine.css?1729268597 rel=stylesheet id=R-variant-style><link href=../../css/chroma-relearn-light.css?1729268597 rel=stylesheet id=R-variant-chroma-style><link href=../../css/print.css?1729268597 rel=stylesheet media=print><script src=../../js/variant.js?1729268597></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.variants&&variants.init(["mine"]),window.T_Copy_to_clipboard=`Copier dans le presse-papiers`,window.T_Copied_to_clipboard=`Copi√© dans le presse-papiers!`,window.T_Copy_link_to_clipboard=`Copier le lien dans le presse-papiers`,window.T_Link_copied_to_clipboard=`Lien copi√© dans le presse-papiers!`,window.T_Reset_view=`R√©initialiser la vue`,window.T_View_reset=`Vue r√©initialis√©e!`,window.T_No_results_found=`Aucun r√©sultat trouv√© pour "{0}"`,window.T_N_results_found=`{1} r√©sultats trouv√©s pour "{0}"`</script></head><body class="mobile-support html disableInlineCopyToClipboard" data-url=../../chapter10/4-sfinae/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table des mati√®res (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><ul><li><a href=#le-besoin>Le besoin</a></li><li><a href=#best-viable-function>Best viable function</a></li><li><a href=#sfinae>SFINAE</a></li></ul></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=../../index.html><span itemprop=name>Accueil</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=../../chapter10/index.html><span itemprop=name>Param√®tres de templates</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>SFINAE</span><meta itemprop=position content="3"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=../../chapter10/3-specializations/index.html title="Sp√©cialisations (ü°ê)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=../../chapter10/test/index.html title="Questionnaire ‚òë (ü°í)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Aller plus loin"><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter10" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=sfinae>SFINAE</h1><p>Nous allons maintenant vous expliquer ce que signifie SFINAE, le besoin auquel ce m√©canisme r√©pond et comment le mettre en oeuvre dans votre code.</p><hr><h3 id=le-besoin>Le besoin</h3><p>Supposons que nous souhaitions pouvoir r√©cup√©rer une clef pour diff√©rents type √† l&rsquo;aide d&rsquo;une fonction <code>get_key(const Type&)</code>, en utilisant des overloads.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>_name</span> <span class=p>{</span> <span class=n>name</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>get_name</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>_name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>_name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Overload pour notre classe Person.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>get_key</span><span class=p>(</span><span class=k>const</span> <span class=n>Person</span><span class=o>&amp;</span> <span class=n>person</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>person</span><span class=p>.</span><span class=n>get_name</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Overload pour un type g√©n√©rique de la librairie standard.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>First</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Second</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>First</span><span class=o>&amp;</span> <span class=n>get_key</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>First</span><span class=p>,</span> <span class=n>Second</span><span class=o>&gt;&amp;</span> <span class=n>pair</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>pair</span><span class=p>.</span><span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span> <span class=n>charles</span> <span class=p>{</span> <span class=s>&#34;Charles&#34;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>get_key</span><span class=p>(</span><span class=n>charles</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=c1>// --&gt; Charles 
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>pair</span> <span class=p>{</span> <span class=s>&#34;eight&#34;</span><span class=p>,</span> <span class=mi>8</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>get_key</span><span class=p>(</span><span class=n>pair</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=c1>// --&gt; eight 
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Supposons maintenant que l&rsquo;on se trouve dans un projet dans lequel de nombreuses classes d√©finissent d√©j√† un getter constant <code>get_key()</code> permettant de renvoyer la clef correspondant √† cet objet :</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Key</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Value</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>KeyValue</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Key</span> <span class=n>key</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=n>Value</span> <span class=n>value</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Key</span><span class=o>&amp;</span> <span class=n>get_key</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>key</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div><p>Plut√¥t que de devoir d√©finir manuellement l&rsquo;overload pour chacuns de ces types, nous souhaiterions que la fonction <code>get_key(const T& obj)</code> puisse √™tre automatiquement g√©n√©r√©e et appelle <code>obj.get_key()</code>.
On pourrait donc avoir quelque chose comme √ßa :</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=n>get_key</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>obj</span><span class=p>.</span><span class=n>get_key</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Key</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Value</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>KeyValue</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Key</span> <span class=n>key</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=n>Value</span> <span class=n>value</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Key</span><span class=o>&amp;</span> <span class=n>get_key</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>key</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>KeyValue</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>kv</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>get_key</span><span class=p>(</span><span class=n>kv</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=c1>// --&gt; 1 
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Incroyable ! Ca fonctionne.</p><p>Essayons maintenant de rajouter l&rsquo;overload pour les <code>std::pair</code>, ainsi que l&rsquo;appel √† la fonction <code>get_key()</code> sur une instance de <code>pair&lt;std::string, int></code>.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;utility&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Overload g√©n√©rique pour tous les types qui contiennent un getter get_key().
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=n>get_key</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>obj</span><span class=p>.</span><span class=n>get_key</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Overload pour un type g√©n√©rique de la librairie standard.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>First</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Second</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>First</span><span class=o>&amp;</span> <span class=n>get_key</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>First</span><span class=p>,</span> <span class=n>Second</span><span class=o>&gt;&amp;</span> <span class=n>pair</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>pair</span><span class=p>.</span><span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Key</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Value</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>KeyValue</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Key</span> <span class=n>key</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=n>Value</span> <span class=n>value</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Key</span><span class=o>&amp;</span> <span class=n>get_key</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>key</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>KeyValue</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>kv</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>get_key</span><span class=p>(</span><span class=n>kv</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=c1>// --&gt; 1
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>pair</span> <span class=p>{</span> <span class=s>&#34;eight&#34;</span><span class=p>,</span> <span class=mi>8</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>get_key</span><span class=p>(</span><span class=n>pair</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=c1>// --&gt; eight
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Extra-ordinaire ! Ca fonctionne toujours !</p><p>Vous vous apercevez maintenant que dans l&rsquo;une des d√©pendences externes de votre projet, vous disposez d&rsquo;une classe polymorphe <code>Procedure</code> contenant une fonction <code>get_id()</code>.<br>Comme vous √™tes malin, vous vous dites que vous allez cr√©er un overload pour <code>const Procedure&</code>, afin que l&rsquo;on puisse passer n&rsquo;importe quelle sous-classe √† la fonction, et que celle-ci appelle <code>get_id()</code> pour d√©terminer la clef de l&rsquo;objet.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Procedure</span> <span class=c1>// suppos√©e hors du projet
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Procedure</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>get_id</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ZeroProcedure</span><span class=o>:</span> <span class=k>public</span> <span class=n>Procedure</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>get_id</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Overload sp√©cifique √† Procedure et ses sous-classes.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>get_key</span><span class=p>(</span><span class=k>const</span> <span class=n>Procedure</span><span class=o>&amp;</span> <span class=n>procedure</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>procedure</span><span class=p>.</span><span class=n>get_id</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Overload g√©n√©rique pour tous les types qui contiennent un getter get_key().
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=n>get_key</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>obj</span><span class=p>.</span><span class=n>get_key</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Key</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Value</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>KeyValue</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Key</span> <span class=n>key</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=n>Value</span> <span class=n>value</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Key</span><span class=o>&amp;</span> <span class=n>get_key</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>key</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>KeyValue</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>kv</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>get_key</span><span class=p>(</span><span class=n>kv</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>ZeroProcedure</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>get_key</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Et l√†, vous vous retrouvez avec cette erreur :</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-b data-lang=b><span class=line><span class=cl><span class=c>error: &#39;const class ZeroProcedure&#39; has no member named &#39;get_key&#39;</span></span></span></code></pre></div><p>Comment √ßa <code>ZeroProcedure</code> n&rsquo;a pas de fonction <code>get_key</code> ??<br>Elle n&rsquo;a pas besoin d&rsquo;une fonction <code>get_key</code>, puisse qu&rsquo;on lui a cr√©√© un super overload qui utilise <code>Procedure::get_id()</code>&mldr;</p><hr><h3 id=best-viable-function>Best viable function</h3><p>Pour vous convaincre que vous n&rsquo;avez pas √©crit n&rsquo;importe quoi pr√©c√©dement, vous allez commenter la version g√©n√©rique de <code>get_key()</code>:</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Procedure</span> <span class=c1>// suppos√©e hors du projet
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Procedure</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>get_id</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ZeroProcedure</span><span class=o>:</span> <span class=k>public</span> <span class=n>Procedure</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>get_id</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Overload sp√©cifique √† Procedure et ses sous-classes.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>get_key</span><span class=p>(</span><span class=k>const</span> <span class=n>Procedure</span><span class=o>&amp;</span> <span class=n>procedure</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>procedure</span><span class=p>.</span><span class=n>get_id</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// // Overload g√©n√©rique pour tous les types qui contiennent un getter get_key().
</span></span></span><span class=line><span class=cl><span class=c1>// template &lt;typename T&gt;
</span></span></span><span class=line><span class=cl><span class=c1>// const auto&amp; get_key(const T&amp; obj)
</span></span></span><span class=line><span class=cl><span class=c1>// {
</span></span></span><span class=line><span class=cl><span class=c1>//     return obj.get_key();
</span></span></span><span class=line><span class=cl><span class=c1>// }
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Key</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Value</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>KeyValue</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Key</span> <span class=n>key</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=n>Value</span> <span class=n>value</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Key</span><span class=o>&amp;</span> <span class=n>get_key</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>key</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// KeyValue&lt;int, int&gt; kv { 1, 2 };
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// std::cout &lt;&lt; get_key(kv) &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=n>ZeroProcedure</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>get_key</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Le code compile √† nouveau.</p><p>Il semblerait donc que lors de l&rsquo;√©tape de r√©solution des appels, si on passe un type <code>Child</code> a une fonction disposant :</p><ul><li>d&rsquo;un overload enti√®rement g√©n√©rique : <code>template &lt;Type> .. fcn(const Type&)</code>,</li><li>d&rsquo;un overload sur le type parent : <code>.. fcn(const Parent&)</code>,<br>ce soit l&rsquo;overload g√©n√©rique qui l&rsquo;emporte syst√©matiquement&mldr;</li></ul><p>Cette fonction choisie par le compilateur s&rsquo;appelle la <strong>best viable function</strong>.<br>Les r√®gles qui d√©finissent ce choix √©tant relativement denses et complexes, nous ne rentrerons pas dans les d√©tails.
Mais si un jour, vous avez besoin de vous y int√©resser, vous pouvez les consulter sur <a href=https://en.cppreference.com/w/cpp/language/overload_resolution rel=external target=_blank>cette page</a>.</p><p>Id√©alement, pour r√©soudre notre probl√®me, il faudrait trouver une astuce permettant de dire au compilateur d&rsquo;ignorer l&rsquo;overload g√©n√©rique afin d&rsquo;appeler la fonction attendant la classe de base.
Cette astuce existe et porte un nom : <strong>SFINAE</strong>.</p><hr><h3 id=sfinae>SFINAE</h3><p>SFINAE signifie : &ldquo;substitution failure is not an error&rdquo;.</p><p>Cela veut dire que si le compilateur n&rsquo;arrive pas √† substituer les param√®tres de template √† partir des arguments pass√©s √† une fonction, il ne va pas g√©n√©rer d&rsquo;erreur de compilation.
Il va simplement ignorer cette d√©finition et tenter de trouver un autre overload √† appeler.</p><p>Dans notre exemple, la fonction g√©n√©rique ne peut fonctionner que si l&rsquo;objet pass√© en param√®tre dispose d&rsquo;un getter <code>get_key</code> n&rsquo;acceptant pas de param√®tre.
Nous allons donc utiliser SFINAE pour emp√™cher le compilateur de consid√©rer <code>get_key(const Type&)</code> si <code>Type</code> ne d√©finit pas ce getter.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;type_traits&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Ret</span> <span class=o>=</span> <span class=k>decltype</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>declval</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>().</span><span class=n>get_key</span><span class=p>())</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>Ret</span> <span class=n>get_key</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>obj</span><span class=p>.</span><span class=n>get_key</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Commen√ßons tout d&rsquo;abord par d√©cortiquer : <code>typename Ret = decltype(std::declval&lt;T>().get_key())</code>:</p><ol><li>On d√©finit un nouveau param√®tre de template nomm√© <code>Ret</code>.</li><li>On lui assigne une valeur par d√©faut.</li><li><code>std::declval&lt;T>()</code> est une fonction de <code>&lt;type_traits></code> permettant d&rsquo;instancier une variable de type <code>T</code> √† la compilation (dans les param√®tres de template par exemple).</li><li>On appelle <code>get_key()</code> sur cette instance.</li><li>On r√©cup√®re le type de la valeur de retour √† l&rsquo;aide du mot-clef <code>decltype</code>.</li><li>La valeur par d√©faut de <code>Ret</code> correspond donc au type de retour de la fonction <code>T::get_key()</code>.</li></ol><p>Essayez de compiler le code suivant, vous devriez constater qu&rsquo;il n&rsquo;y a plus d&rsquo;erreur de compilation et que tout se passe comme attendu :</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;type_traits&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Procedure</span> <span class=c1>// suppos√©e hors du projet
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Procedure</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>get_id</span><span class=p>()</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ZeroProcedure</span><span class=o>:</span> <span class=k>public</span> <span class=n>Procedure</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>get_id</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Overload sp√©cifique √† Procedure et ses sous-classes.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>get_key</span><span class=p>(</span><span class=k>const</span> <span class=n>Procedure</span><span class=o>&amp;</span> <span class=n>procedure</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>procedure</span><span class=p>.</span><span class=n>get_id</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Overload g√©n√©rique pour tous les types qui contiennent un getter get_key().
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Ret</span> <span class=o>=</span> <span class=k>decltype</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>declval</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>().</span><span class=n>get_key</span><span class=p>())</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>Ret</span> <span class=n>get_key</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>obj</span><span class=p>.</span><span class=n>get_key</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Key</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Value</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>KeyValue</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Key</span> <span class=n>key</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=n>Value</span> <span class=n>value</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Key</span><span class=o>&amp;</span> <span class=n>get_key</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>key</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>KeyValue</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>kv</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>get_key</span><span class=p>(</span><span class=n>kv</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>ZeroProcedure</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>get_key</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Ce qu&rsquo;il s&rsquo;est produit ici, c&rsquo;est que lorsque le compilateur a regard√© si l&rsquo;overload g√©n√©rique de <code>get_key()</code> pouvait √™tre utilis√© avec <code>ZeroProcedure</code>, il n&rsquo;a pas r√©ussi √† g√©n√©rer la signature de la fonction √† partir des types fournis.<br>En effet, il a pu remplacer <code>T</code> par <code>ZeroProcedure</code>.
Cependant, pour d√©terminer <code>Ret</code>, il a √©t√© oblig√© d&rsquo;√©valuer sa valeur par d√©faut, √† savoir le type de retour de <code>ZeroProcedure::get_key()</code>.<br>Comme cette fonction n&rsquo;existe pas, la substitution a √©chou√©e, et le compilateur a donc s√©lectionn√© la fonction candidate suivante, √† savoir <code>get_key(const Procedure&)</code>.</p><p>Pour d√©clencher des √©checs de substitution, vous pouvez vous placer soit au niveau des param√®tres de template (type ou valeur par d√©faut), soit au niveau de la signature de la fonction (type des param√®tres ou leurs valeurs par d√©faut), soit au niveau du type de retour de la fonction.</p><p>Choisir ce dernier permet g√©n√©ralement d&rsquo;utiliser <code>std::enable_if_t&lt;condition, type></code>, ainsi que de nombreux autres utilitaires d√©finis dans <code>&lt;type_traits></code>.<br>Voici par exemple une fa√ßon de d√©finir une fonction qui n&rsquo;existe que pour les types entiers :</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;type_traits&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// La substitution fonctionne seulement si T est entier.
</span></span></span><span class=line><span class=cl><span class=c1>// La fonction renvoie alors un T.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>enable_if_t</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>is_integer_v</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>add_two</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>value</span> <span class=o>+</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// La substitution fonctionne seulement si v1 et v2 sont de m√™mes types.
</span></span></span><span class=line><span class=cl><span class=c1>// La fonction renvoie alors un bool√©en.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T1</span><span class=p>,</span> <span class=k>typename</span> <span class=n>T2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>enable_if_t</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>is_same_v</span><span class=o>&lt;</span><span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=o>&gt;&gt;</span><span class=p>,</span> <span class=kt>bool</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>are_equal</span><span class=p>(</span><span class=k>const</span> <span class=n>T1</span><span class=o>&amp;</span> <span class=n>v1</span><span class=p>,</span> <span class=k>const</span> <span class=n>T2</span><span class=o>&amp;</span> <span class=n>v2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>v1</span> <span class=o>==</span> <span class=n>v2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><footer class=footline></footer></article></div></main></div><aside id=R-sidebar class="default-animation showVisitedLinks"><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=logo href=../../>üéÑ C++ üéÑ</a></div></div><div id=R-homelinks class=default-animation><hr class=padding></div><div id=R-content-wrapper class=highlightable><div id=R-topics><ul class="enlarge morespace collapsible-menu"><li data-nav-id=/chapter0/index.html><a class=padding href=../../chapter0/index.html><b>0- </b>Mise en place<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-bb41caf94f12b8a1a4b5e560230e7851 class=collapsible-menu></ul></li><li data-nav-id=/chapter1/index.html><a class=padding href=../../chapter1/index.html><b>1- </b>Introduction au C++<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-6c398714eae4372920aec3a1e6c2e143 class=collapsible-menu></ul></li><li data-nav-id=/chapter2/index.html><a class=padding href=../../chapter2/index.html><b>2- </b>Classes<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-b1df0095a9fd74320697a6d478418ec3 class=collapsible-menu></ul></li><li data-nav-id=/chapter3/index.html><a class=padding href=../../chapter3/index.html><b>3- </b>Cycle de vie<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-9f6546bce6f8e9a77063b71c880fd5b8 class=collapsible-menu></ul></li><li data-nav-id=/chapter4/index.html><a class=padding href=../../chapter4/index.html><b>4- </b>H√©ritage<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-48065e8b6e7e69533ca73b3931c8a0a1 class=collapsible-menu></ul></li><li data-nav-id=/chapter5/index.html><a class=padding href=../../chapter5/index.html><b>5- </b>Librairie standard<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-86528e6ba587b53932a1dafaa9cd375c class=collapsible-menu></ul></li><li data-nav-id=/chapter6/index.html><a class=padding href=../../chapter6/index.html><b>6- </b>Algorithmes<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-016ee40825ff7c4aeecbac08a8ca264b class=collapsible-menu></ul></li><li data-nav-id=/chapter9/index.html><a class=padding href=../../chapter9/index.html><b>7- </b>Templates<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-24ddf636ccd0ce3ef39c8060d1779332 class=collapsible-menu></ul></li><li class=parent data-nav-id=/chapter10/index.html><a class=padding href=../../chapter10/index.html><b>8- </b>Param√®tres de templates<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-66e6e0c58d73995ecc09e8fbbe358e51 class=collapsible-menu><li data-nav-id=/chapter10/1-universal-ref/index.html><a class=padding href=../../chapter10/1-universal-ref/index.html>R√©f√©rence universelle<i class="fa-fw fas fa-check read-icon"></i></a></li><li data-nav-id=/chapter10/2-variadiac/index.html><a class=padding href=../../chapter10/2-variadiac/index.html>Template variadique<i class="fa-fw fas fa-check read-icon"></i></a></li><li data-nav-id=/chapter10/3-specializations/index.html><a class=padding href=../../chapter10/3-specializations/index.html>Sp√©cialisations<i class="fa-fw fas fa-check read-icon"></i></a></li><li class=active data-nav-id=/chapter10/4-sfinae/index.html><a class=padding href=../../chapter10/4-sfinae/index.html>SFINAE<i class="fa-fw fas fa-check read-icon"></i></a></li><li data-nav-id=/chapter10/test/index.html><a class=padding href=../../chapter10/test/index.html>Questionnaire ‚òë<i class="fa-fw fas fa-check read-icon"></i></a></li></ul></li></ul></div><div id=R-shortcuts><div class="nav-title padding">Acc√®s rapide</div><ul class=space><li><a class=padding href=https://github.com/Laefy/CPP_Learning_Code/><i class='fab fa-github'></i> D√©p√¥t Cours</a></li><li><a class=padding href=https://github.com/Laefy/CPP_Exercises/><i class='fab fa-github'></i> D√©p√¥t TPs</a></li><li><a class=padding href=../../slides/index.html><i class='far fa-file-powerpoint'></i> Slides</a></li><li><a class=padding href=../../workflow/index.html><i class='far fa-list-alt'></i> Workflow</a></li><li><a class=padding href=../../faq/index.html><i class='fas fa-question-circle'></i> FAQ</a></li><li><a class=padding href=../../chapter0/6-tips/index.html><i class='fa fa-rocket'></i> Astuces</a></li><li><a class=padding href=https://godbolt.org/><i class='fas fa-cog'></i> Compiler Explorer</a></li><li><a class=padding href=https://en.cppreference.com/w/><i class='fas fa-passport'></i> CPP-Ref</a></li></ul></div><div class="padding footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVisitedLinks showFooter"></div><div id=R-menu-footer><hr class="padding default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVisitedLinks showFooter"><div id=R-prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVisitedLinks"><ul><li id=R-select-language-container class=footerLangSwitch><div class="padding menu-control"><i class="fa-fw fas fa-language"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-language>Langue</label>
<select id=R-select-language onchange="location=this.querySelector(this.value).dataset.url"><option id=R-select-language-fr value=#R-select-language-fr data-url=../../chapter10/4-sfinae/index.html lang=fr selected>Fran√ßais</option></select></div><div class=clear></div></div></li><li id=R-select-variant-container class=footerVariantSwitch><div class="padding menu-control"><i class="fa-fw fas fa-paint-brush"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-variant>Th√®me</label>
<select id=R-select-variant onchange=window.variants&&variants.changeVariant(this.value)><option id=R-select-variant-mine value=mine selected>Mine</option></select></div><div class=clear></div></div><script>window.variants&&variants.markSelectedVariant()</script></li><li class="footerVisitedLinks showVisitedLinks"><div class="padding menu-control"><i class="fa-fw fas fa-history"></i>
<span>&nbsp;</span><div class=control-style><button onclick=clearHistory()>Supprimer l'historique</button></div><div class=clear></div></div></li></ul></div><div id=R-footer class="footerFooter showFooter"><p>Built with <a href=https://github.com/McShelby/hugo-theme-relearn title=love><i class="fas fa-heart"></i></a> by <a href=https://gohugo.io/>Hugo</a></p></div></div></div></aside><script src=../../js/clipboard.min.js?1729268597 defer></script><script src=../../js/perfect-scrollbar.min.js?1729268597 defer></script><script src=../../js/theme.js?1729268597 defer></script><button id=footer-question-btn title="Envoyer un message √† propos du texte s√©lectionn√©" onclick=openQuestionForm() disabled><i class="fas fa-question-circle"></i></button><div id=footer-question-window disabled><form id=question method=POST action=https://formsubmit.co/3aa0f379a1aed9c454634cc2da153a7b target=question-submitted onsubmit=cleanQuestionFormContent()><input type=email name=email placeholder=mon_email@smthg.com required onchange=updateQuestionFormSubject()>
<textarea name=question rows=7 cols=30 placeholder="Mon message..."></textarea>
<input type=hidden name=selection>
<input type=hidden name=_replyto>
<input type=hidden name=_subject>
<input type=hidden name=_template value=box>
<input type=hidden name=_captcha value=false>
<input type=hidden name=_next value=//question-submitted/>
<input type=submit disabled style=display:none aria-hidden=true>
<input type=submit value=Envoyer></form><iframe class=hidden name=question-submitted src></iframe></div><script>function updateQuestionFormSubject(){let e=document.querySelector('#question>input[name="email"]').value;document.querySelector('#question>input[name="_subject"]').value="[C++][Chapitre 8] "+e+", retour sur ta question"}function cleanQuestionFormContent(){function e(e){e.value=e.value.replace(/\[\.\./g,"[ ..")}e(document.querySelector('#question>textarea[name="question"]')),e(document.querySelector('#question>input[name="selection"]'))}function openQuestionForm(){document.getElementById("footer-question-window").removeAttribute("disabled");var e=window.getSelection().toString();document.querySelector('#question>input[name="selection"]').value=e}function updateQuestionWidgetState(e){var t=document.getElementById("R-body-inner"),n=window.getSelection(),s=document.getElementById("footer-question-window");document.getElementById("footer-question-btn").disabled=n.isCollapsed||t==null||t.contains(n.anchorNode)==!1||t.contains(n.focusNode)==!1,e!==void 0&&e.type=="mouseup"&&s.contains(e.target)==!1&&s.contains(document.activeElement)==!1&&s.setAttribute("disabled",!0)}updateQuestionFormSubject(),document.onmouseup=document.onkeyup=document.onselectionchange=updateQuestionWidgetState,updateQuestionWidgetState()</script></body></html>