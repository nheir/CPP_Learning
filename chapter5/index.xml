<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Librairie standard :: Cours de C++ - Niveau Master</title><link>/chapter5/index.html</link><description>Dans ce chapitre, nous vous prÃ©senterons les diffÃ©rents types de conteneurs que vous pourrez trouver dans la librairie standard. Les exercices vous permettrons de vous familiariser avec certains dâ€™entre-eux : vector et string bien sÃ»r, mais aussi array, string_view, list, map ou encore pair. Nous en profiterons Ã©galement pour vous expliquer comment la documentation est organisÃ©e sur le site cppreference, afin que vous sachiez toujours Ã  quel endroit dâ€™une page regarder pour trouver les informations dont vous avez besoin.</description><generator>Hugo</generator><language>fr</language><atom:link href="/chapter5/index.xml" rel="self" type="application/rss+xml"/><item><title>Un peu de doc...</title><link>/chapter5/1-doc/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter5/1-doc/index.html</guid><description>Pour dÃ©marrez ce chapitre, nous allons vous expliquer comment parcourir la documentation que vous trouverez sur le site cppreference.
Commencez par ouvrir cette page. Vous y trouverez la documentation de la classe vector.
A premiÃ¨re vue, son contenu peut paraÃ®tre indigeste. Nous allons donc vous expliquer comment il est structurÃ© afin que vous puissiez vous y repÃ©rer plus facilement.
Documentation dâ€™une classe 1. En-tÃªte Dans lâ€™en-tÃªte de la documentation, vous trouverez le nom de la classe, suivi du header Ã  inclure afin de pouvoir lâ€™utiliser.</description></item><item><title>Tableaux dynamiques</title><link>/chapter5/2-vectors/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter5/2-vectors/index.html</guid><description>Vous apprendrez ici Ã  utiliser des vector de maniÃ¨re un peu plus avancÃ©e : construction, accÃ¨s, insertions, suppressions et recherches nâ€™auront plus de secrets pour vous !
Pour cet exercice, vous modifierez le fichier :
- chap-05/1-vectors.cpp
La cible Ã  compiler est c5-1-vectors.
Construction Au chapitre prÃ©cÃ©dent, nous vous avions prÃ©sentÃ© diffÃ©rentes syntaxes permettant dâ€™instancier une classe. Nous vous avions en particulier indiquer quâ€™il Ã©tait possible dâ€™utiliser la syntaxe Class c { p1, p2 }; ou bien la syntaxe Class c(p1, p2);.</description></item><item><title>Autres conteneurs sÃ©quentiels</title><link>/chapter5/3-sequentials/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter5/3-sequentials/index.html</guid><description>Vous allez maintenant manipuler les autres conteneurs sÃ©quentiels que la libraire propose.
Pour cet exercice, vous modifierez le fichier :
- chap-05/2-sequentials.cpp
La cible Ã  compiler est c5-2-sequentials.
Tableaux de taille fixe Pour crÃ©er des tableaux de taille fixe, il est bien entendu possible dâ€™utiliser les tableaux primitifs. Lâ€™inconvÃ©nient, câ€™est quâ€™il faut penser Ã  les initialiser, ce que tout le monde ne pense pas toujours Ã  faireâ€¦.
Du coup, pour pallier Ã  ce problÃ¨me, il est possible dâ€™utiliser la classe std::array.</description></item><item><title>Conteneurs associatifs</title><link>/chapter5/4-associatives/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter5/4-associatives/index.html</guid><description>Un conteneur associatif est un conteneur dans lequel les Ã©lÃ©ments peuvent Ãªtre indexÃ©s par des objets, et non plus seulement par des entiers.
Vous allez donc ici voir les diffÃ©rents types de conteneurs associatifs proposÃ©s par la STL.
Pour cet exercice, vous modifierez les fichiers :
- chap-05/3-associatives/main.cpp
- chap-05/3-associatives/keys.h
La cible Ã  compiler est c5-3-associatives.
Les sets (ensembles) Un set est un conteneur dans lequel les Ã©lÃ©ments sont â€œindexÃ©s par eux-mÃªmesâ€.</description></item><item><title>Manipulation de chaÃ®nes</title><link>/chapter5/5-strings/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter5/5-strings/index.html</guid><description>Dans cette partie, nous reviendrons sur les fonctions fournies par la librairie permettant de manipuler des string. Vous apprendrez aussi ce que sont les string_view et Ã  quoi elles servent.
Pour cet exercice, vous modifierez le fichier :
- chap-05/4-strings.cpp
La cible Ã  compiler est c5-4-strings.
OpÃ©rations standards Parmis les opÃ©rations standards que lâ€™on peut effectuer sur des chaÃ®nes de caractÃ¨re, on retrouve :
la concatÃ©nation, lâ€™extration de sous-chaÃ®ne, la recherche de caractÃ¨re ou de sous-chaÃ®ne, la comparaison, le remplacement dâ€™une partie de la chaÃ®ne.</description></item><item><title>Paires et tuples</title><link>/chapter5/6-tuples/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter5/6-tuples/index.html</guid><description>Vous avez dÃ©jÃ  utilisÃ© le type pair au cours dâ€™exercices prÃ©cÃ©dents. Nous allons maintenant vous prÃ©senter son cousin, la classe tuple.
Pour cet exercice, vous modifierez le fichier :
- chap-05/5-tuples.cpp
La cible Ã  compiler est c5-5-tuples.
Micro rappel sur les pair La classe pair est un type templatÃ© avec deux paramÃ¨tres :
std::pair&lt;int, float> such_a_nice_pair { 1, 3.f }; On accÃ¨de aux Ã©lÃ©ments de la pair directement via ses attributs first et second (pas de getters) :</description></item><item><title>Questionnaire â˜‘</title><link>/chapter5/test/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter5/test/index.html</guid><description>Le premier objectif de ce chapitre Ã©tait de vous prÃ©senter quelques classes de la STL, leurs rÃ´les, leurs diffÃ©rences, dans quelles situations les utiliser et comment.
Il avait Ã©galement un deuxiÃ¨me objectif, qui Ã©tait en quelque sorte de vous apprendre Ã  vous dÃ©brouiller tout seul : vous devriez dÃ©sormais Ãªtre capable de rechercher par vous-mÃªme des informations dans la documentation, et vous devriez aussi apprÃ©hender un peu mieux quâ€™avant les messages du compilateur.</description></item><item><title>SynthÃ¨se</title><link>/chapter5/summary/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter5/summary/index.html</guid><description>Ce quâ€™il faut retenir ThÃ©orie Un conteneur sÃ©quentiel est un conteneur dans lequel les Ã©lements se suivent (tableaux, listes, â€¦). Un conteneur associatif est un conteneur dans lequel chaque Ã©lÃ©ment est indexÃ© par une clef (lâ€™Ã©lÃ©ment pouvant Ãªtre la clef elle-mÃªme). Les types passÃ©s en paramÃ¨tre de template doivent parfois respecter des contraintes pour compiler (ces contraintes sont spÃ©cifiÃ©es dans la documentation). Librairie standard Tableau de taille dynamique : vector Tableau de taille fixe : array Listes chaÃ®nÃ©es : list ou forward_list Ensembles : set ou unordered_set Dictionnaires : map ou unordered_map Pratique On peut passer les chaÃ®nes de caractÃ¨res constantes par std::string_view plutÃ´t que const std::string&amp; ou const char*.</description></item><item><title>Merci !</title><link>/chapter5/test_done/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/chapter5/test_done/index.html</guid><description>Vos rÃ©ponses nous ont bien Ã©tÃ© communiquÃ©es ğŸ˜ƒ N'hÃ©sitez pas Ã  nous relancer si vous n'avez pas eu de nouvelles aprÃ¨s une semaine !</description></item></channel></rss>