<!doctype html><html lang=fr dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 7.0.1+72a875f1db967152c77914cff4d53f8fcee0e619"><meta name=description content="Parcours de plages Pour parcourir une plage d‚Äô√©l√©ments, vous devriez normalement d√©j√† savoir qu‚Äôil faut utiliser une boucle for ou foreach. Les boucles while et do-while ne sont en effet pas vraiment adapt√©es √† ce type d‚Äôusage.
Vous trouverez quelques conseils dans cette partie pour rendre votre code plus lisible, concis et fiable.
Boucle foreach Lorsqu‚Äôon it√®re sur un conteneur avec une boucle foreach, il faut faire attention √† si l‚Äôon souhaite r√©cup√©rer une copie de l‚Äô√©l√©ment ou une r√©f√©rence."><meta name=author content><meta name=twitter:card content="summary"><meta name=twitter:title content="Parcours et recherches :: Cours de C++ - Niveau Master"><meta name=twitter:description content="Parcours de plages Pour parcourir une plage d‚Äô√©l√©ments, vous devriez normalement d√©j√† savoir qu‚Äôil faut utiliser une boucle for ou foreach. Les boucles while et do-while ne sont en effet pas vraiment adapt√©es √† ce type d‚Äôusage.
Vous trouverez quelques conseils dans cette partie pour rendre votre code plus lisible, concis et fiable.
Boucle foreach Lorsqu‚Äôon it√®re sur un conteneur avec une boucle foreach, il faut faire attention √† si l‚Äôon souhaite r√©cup√©rer une copie de l‚Äô√©l√©ment ou une r√©f√©rence."><meta property="og:url" content="/chapter6/1-searches/index.html"><meta property="og:site_name" content="Cours de C++ - Niveau Master"><meta property="og:title" content="Parcours et recherches :: Cours de C++ - Niveau Master"><meta property="og:description" content="Parcours de plages Pour parcourir une plage d‚Äô√©l√©ments, vous devriez normalement d√©j√† savoir qu‚Äôil faut utiliser une boucle for ou foreach. Les boucles while et do-while ne sont en effet pas vraiment adapt√©es √† ce type d‚Äôusage.
Vous trouverez quelques conseils dans cette partie pour rendre votre code plus lisible, concis et fiable.
Boucle foreach Lorsqu‚Äôon it√®re sur un conteneur avec une boucle foreach, il faut faire attention √† si l‚Äôon souhaite r√©cup√©rer une copie de l‚Äô√©l√©ment ou une r√©f√©rence."><meta property="og:locale" content="fr"><meta property="og:type" content="article"><meta property="article:section" content="Algorithmes"><meta itemprop=name content="Parcours et recherches :: Cours de C++ - Niveau Master"><meta itemprop=description content="Parcours de plages Pour parcourir une plage d‚Äô√©l√©ments, vous devriez normalement d√©j√† savoir qu‚Äôil faut utiliser une boucle for ou foreach. Les boucles while et do-while ne sont en effet pas vraiment adapt√©es √† ce type d‚Äôusage.
Vous trouverez quelques conseils dans cette partie pour rendre votre code plus lisible, concis et fiable.
Boucle foreach Lorsqu‚Äôon it√®re sur un conteneur avec une boucle foreach, il faut faire attention √† si l‚Äôon souhaite r√©cup√©rer une copie de l‚Äô√©l√©ment ou une r√©f√©rence."><meta itemprop=wordCount content="2924"><title>Parcours et recherches :: Cours de C++ - Niveau Master</title>
<link href=../../css/fontawesome-all.min.css?1729268528 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/fontawesome-all.min.css?1729268528 rel=stylesheet></noscript><link href=../../css/nucleus.css?1729268528 rel=stylesheet><link href=../../css/auto-complete.css?1729268528 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/auto-complete.css?1729268528 rel=stylesheet></noscript><link href=../../css/perfect-scrollbar.min.css?1729268528 rel=stylesheet><link href=../../css/fonts.css?1729268528 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=../../css/fonts.css?1729268528 rel=stylesheet></noscript><link href=../../css/theme.css?1729268528 rel=stylesheet><link href=../../css/theme-mine.css?1729268528 rel=stylesheet id=R-variant-style><link href=../../css/chroma-relearn-light.css?1729268528 rel=stylesheet id=R-variant-chroma-style><link href=../../css/print.css?1729268528 rel=stylesheet media=print><script src=../../js/variant.js?1729268528></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.variants&&variants.init(["mine"]),window.T_Copy_to_clipboard=`Copier dans le presse-papiers`,window.T_Copied_to_clipboard=`Copi√© dans le presse-papiers!`,window.T_Copy_link_to_clipboard=`Copier le lien dans le presse-papiers`,window.T_Link_copied_to_clipboard=`Lien copi√© dans le presse-papiers!`,window.T_Reset_view=`R√©initialiser la vue`,window.T_View_reset=`Vue r√©initialis√©e!`,window.T_No_results_found=`Aucun r√©sultat trouv√© pour "{0}"`,window.T_N_results_found=`{1} r√©sultats trouv√©s pour "{0}"`</script></head><body class="mobile-support html disableInlineCopyToClipboard" data-url=../../chapter6/1-searches/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table des mati√®res (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><ul><li><a href=#parcours-de-plages>Parcours de plages</a></li><li><a href=#recherche-d√©l√©ments>Recherche d&rsquo;√©l√©ments</a></li><li><a href=#v√©rification-globale-de-pr√©dicats>V√©rification globale de pr√©dicats</a></li><li><a href=#compter-des-√©l√©ments>Compter des √©l√©ments</a></li><li><a href=#min-et-max>Min et max</a></li><li><a href=#comparaison-de-plages>Comparaison de plages</a></li></ul></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=../../index.html><span itemprop=name>Accueil</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=../../chapter6/index.html><span itemprop=name>Algorithmes</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Parcours et recherches</span><meta itemprop=position content="3"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=../../chapter6/index.html title="Algorithmes (ü°ê)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=../../chapter6/2-transformations/index.html title="Transformations (ü°í)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Aller plus loin"><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter6" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=parcours-et-recherches>Parcours et recherches</h1><h3 id=parcours-de-plages>Parcours de plages</h3><p>Pour parcourir une plage d&rsquo;√©l√©ments, vous devriez normalement d√©j√† savoir qu&rsquo;il faut utiliser une boucle <code>for</code> ou foreach.
Les boucles <code>while</code> et <code>do-while</code> ne sont en effet pas vraiment adapt√©es √† ce type d&rsquo;usage.</p><p>Vous trouverez quelques conseils dans cette partie pour rendre votre code plus lisible, concis et fiable.</p><hr><h5 id=boucle-foreach>Boucle foreach</h5><p>Lorsqu&rsquo;on it√®re sur un conteneur avec une boucle foreach, il faut faire attention √† si l&rsquo;on souhaite r√©cup√©rer une copie de l&rsquo;√©l√©ment ou une r√©f√©rence.</p><p>Lorsque l&rsquo;on ne souhaite pas modifier le contenu du conteneur et que les √©l√©ments sont l√©gers √† copier (primitives par exemple) :</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>e</span> <span class=p>:</span> <span class=n>ctn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>e</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Lorsque l&rsquo;on ne souhaite pas modifier le contenu du conteneur et que la copie des √©l√©ments peut √™tre co√ªteuse :</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>e</span> <span class=p>:</span> <span class=n>ctn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>e</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Lorsque l&rsquo;on souhaite modifier le contenu du conteneur :</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>e</span> <span class=p>:</span> <span class=n>ctn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span> <span class=o>=</span> <span class=n>compute_next</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Certains conteneurs stockent leurs √©l√©ments sous forme de tuples.
Par exemple, les <code>std::map</code> et les <code>std::unordered_map</code> contiennent des <code>std::pair&lt;key, value></code>.<br>Lorsque c&rsquo;est le cas, il est aussi possible d&rsquo;utiliser un <strong>structured binding</strong> pour rendre le contenu de la boucle plus lisible.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Sans structured binding
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=nl>kv</span> <span class=p>:</span> <span class=n>map</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Key: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>kv</span><span class=p>.</span><span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; Value: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>kv</span><span class=p>.</span><span class=n>second</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Avec structured binding
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=p>[</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>]</span> <span class=o>:</span> <span class=n>map</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Key: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>key</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; Value: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>value</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><hr><h5 id=boucle-for-avec-indice>Boucle for avec indice</h5><p>Il est possible d&rsquo;utiliser une boucle <code>for</code> pour it√©rer sur un conteneur disposant d&rsquo;un <code>operator[]</code> attendant un entier (<code>int</code>, <code>unsigned int</code>, <code>size_t</code>).</p><div class="box notices cstyle tip"><div class=box-label><i class="fa-fw fas fa-lightbulb"></i> Astuce</div><div class=box-content><p>Il est pr√©f√©rable de ne les utiliser que lorsque l&rsquo;on ne cherche pas √† ajouter ou supprimer des √©l√©ments du conteneur (<code>for</code> avec it√©rateur est plus adapt√© dans ce cas), et que l&rsquo;indice est utilis√© pour autre chose que l&rsquo;acc√®s √† l&rsquo;√©l√©ment (foreach suffit alors).</p></div></div><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>end</span> <span class=o>=</span> <span class=n>ctn</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span> <span class=o>!=</span> <span class=n>end</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>ctn</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; is at index &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><div class="box notices cstyle tip"><div class=box-label><i class="fa-fw fas fa-lightbulb"></i> Astuce</div><div class=box-content><p>Lorsque le processeur essaye de mettre une valeur dans un registre dans lequel elle ne peut pas tenir (valeur trop grande ou trop petite), on parle d&rsquo;overflow.
Pour √©viter ce type de probl√®me, il faut prendre comme type d&rsquo;indice celui renvoy√© par <code>ctn.size()</code>.
C&rsquo;est aussi une des bonnes raisons de pr√©f√©rer les boucles foreach ou <code>for</code> avec it√©rateurs aux boucles <code>for</code> avec indice.</p></div></div><div class="box notices cstyle tip"><div class=box-label><i class="fa-fw fas fa-lightbulb"></i> Astuce</div><div class=box-content><p>Il est pr√©f√©rable de calculer l&rsquo;indice de fin dans la zone d&rsquo;initialisation du <code>for</code>, plut√¥t qu&rsquo;au niveau de la condition.
Si vous ne pouvez pas le faire car celui-ci n&rsquo;est pas constant (car vous ajoutez ou retirez des √©l√©ments dans le corps de la boucle), cela signifie qu&rsquo;il serait judicieux de remplacer votre boucle par un <code>for</code> avec it√©rateurs.</p></div></div><hr><h5 id=boucle-for-avec-it√©rateurs>Boucle for avec it√©rateurs</h5><p>La boucle <code>for</code> avec it√©rateurs est la boucle la plus adapt√©e pour ajouter ou supprimer les √©l√©ments d&rsquo;un conteneur pendant qu&rsquo;on le parcourt.<br>En effet, les autres types de parcours permettent rarement de traiter correctement l&rsquo;invalidation des it√©rateurs.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Retire les √©l√©ments pairs.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>ctn</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>ctn</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>it</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ctn.erase(it) invalide it.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// On ne peut donc pas utiliser it apr√®s cet appel : on ne pourrait ni √©crire *it, ni ++it.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// C&#39;est pour cela que la fonction erase renvoie un nouvel it√©rateur, valide, sur l&#39;√©l√©ment suivant celui qui a √©t√© retir√©.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// En √©crivant it = ctn.erase(it), on peut donc √† nouveau utiliser la variable it.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>it</span> <span class=o>=</span> <span class=n>ctn</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>++</span><span class=n>it</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Ajoute une copie de chaque √©l√©ment au tableau.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>ctn</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>ctn</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=n>it</span> <span class=o>+=</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ctn.insert(it, ...) invalide
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>it</span> <span class=o>=</span> <span class=n>ctn</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>it</span><span class=p>,</span> <span class=o>*</span><span class=n>it</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><hr><h5 id=boucle-stdfor_each>Boucle std::for_each</h5><p>Il est √©galement possible d&rsquo;utiliser la fonction <code>std::for_each</code> de <code>&lt;algorithm></code> pour it√©rer sur une plage de valeurs.<br>L&rsquo;int√©r√™t de cette fonction, par rapport au foreach classique, c&rsquo;est que l&rsquo;on peut passer les it√©rateurs de d√©but et de fin de notre choix.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;algorithm&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>display_single</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>display_many</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>values</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// On peut passer une fonction libre avec le bon prototype.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>for_each</span><span class=p>(</span><span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>display_single</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// On peut aussi passer une lambda.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>for_each</span><span class=p>(</span><span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=p>[](</span><span class=kt>int</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span> <span class=n>display_single</span><span class=p>(</span><span class=n>v</span><span class=p>);</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><hr><h3 id=recherche-d√©l√©ments>Recherche d&rsquo;√©l√©ments</h3><p>Parlons maintenant de comment retrouver un ou des √©l√©ments √† l&rsquo;int√©rieur d&rsquo;une plage.
Vous pourriez bien s√ªr faire une boucle et recherchez ce dont vous avez besoin manuellement.<br>Mais pourquoi s&rsquo;emb√™ter √† √©crire des boucles, lorsque tout un tas de fonctions existent d√©j√† pour nous √©viter d&rsquo;avoir √† le faire.</p><hr><h5 id=recherche-de-la-premi√®re-occurrence-dun-√©l√©ment>Recherche de la premi√®re occurrence d&rsquo;un √©l√©ment</h5><p>Pour rechercher un √©l√©ment bien pr√©cis dans une plage quelconque, vous pouvez utiliser <code>std::find</code> de <code>&lt;algorithm></code>.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>searched</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find</span><span class=p>(</span><span class=n>ctn</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>ctn</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>searched</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Si la valeur n&#39;est pas trouv√©e, `it` prend la m√™me valeur que le 2e argument pass√© √† std::find.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=k>auto</span> <span class=n>found</span> <span class=o>=</span> <span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>ctn</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>searched</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>found</span> <span class=o>?</span> <span class=s>&#34;found&#34;</span> <span class=o>:</span> <span class=s>&#34;not found&#34;</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;in ctn.&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>found</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>auto</span> <span class=n>half_begin</span> <span class=o>=</span> <span class=n>ctn</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>auto</span> <span class=n>half_end</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>next</span><span class=p>(</span><span class=n>half_begin</span><span class=p>,</span> <span class=n>ctn</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>/</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>auto</span> <span class=n>half_it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find</span><span class=p>(</span><span class=n>half_begin</span><span class=p>,</span> <span class=n>half_end</span><span class=p>,</span> <span class=n>searched</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>half_it</span> <span class=o>!=</span> <span class=n>half_end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>searched</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;found in first half of ctn.&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><div class="box notices cstyle tip"><div class=box-label><i class="fa-fw fas fa-lightbulb"></i> Astuce</div><div class=box-content><p>Certains conteneurs, comme <code>set</code>, <code>unordered_set</code>, <code>map</code> ou <code>unordered_map</code>, proposent une fonction de recherche ayant une meilleure complexit√© que <code>std::find</code> (qui est en O(n)).
Afin d&rsquo;impl√©menter des programmes efficaces, regardez donc toujours si vos conteneurs ne disposent pas de fonctions-membre permettant d&rsquo;effectuer des op√©rations plus efficacement que les fonctions de <code>&lt;algorithm></code>.</p></div></div><hr><h5 id=recherche-invers√©e>Recherche invers√©e</h5><p><code>std::find</code> renvoie toujours l&rsquo;it√©rateur sur la premi√®re occurrence qu&rsquo;il trouve.
Si vous souhaitez rechercher la derni√®re occurrence, il est donc n√©cessaire de fournir des it√©rateurs permettant de parcourir la plage √† l&rsquo;envers.</p><p>Pour cela, il faut :</p><ul><li>transformer les it√©rateurs permettant d&rsquo;avancer en it√©rateurs permettant de reculer : <code>std::make_reverse_iterator(it)</code> dans <code>&lt;iterator></code></li><li>les inverser dans l&rsquo;appel √† <code>std::find</code>.</li></ul><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>searched</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>reversed_begin</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_reverse_iterator</span><span class=p>(</span><span class=n>ctn</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>reversed_end</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_reverse_iterator</span><span class=p>(</span><span class=n>ctn</span><span class=p>.</span><span class=n>begin</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find</span><span class=p>(</span><span class=n>reversed_begin</span><span class=p>,</span> <span class=n>reversed_end</span><span class=p>,</span> <span class=n>searched</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Il faut toujours comparer au 2e argument de find, c&#39;est-√†-dire reversed_end et non pas ctn.end().
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>reversed_end</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>auto</span> <span class=n>pos</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>distance</span><span class=p>(</span><span class=n>reversed_begin</span><span class=p>,</span> <span class=n>it</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>pos</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;-th element from the end of ctn is a &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>searched</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;.&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><div class="box notices cstyle note"><div class=box-label><i class="fa-fw fas fa-exclamation-circle"></i> Remarque</div><div class=box-content><p>Il n&rsquo;est pas toujours possible de parcourir une plage √† l&rsquo;envers.
Seuls les it√©rateurs bidirectionnels peuvent √™tre pass√©s √† la fonction <code>std::make_reverse_iterator</code>.</p></div></div><hr><h5 id=recherche-du-premier-√©l√©ment-appartenant-√†-un-groupe>Recherche du premier √©l√©ment appartenant √† un groupe</h5><p>Dans certains cas, on recherche la premi√®re occurrence parmi un ensemble.<br>Par exemple, pour retrouver dans un texte le premier mot parmis <code>cheval</code>, <code>dodo</code>, <code>chien</code> et <code>bernard-l'ermite</code>, il faudrait faire 4 recherches si l&rsquo;on utilisait <code>std::find</code>.</p><p>Afin d&rsquo;effectuer cette recherche en une seule passe, il est possible d&rsquo;utiliser <code>std::find_first_of</code>.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>text</span> <span class=o>=</span> <span class=n>get_text</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>keywords</span> <span class=p>{</span> <span class=s>&#34;horse&#34;</span><span class=p>,</span> <span class=s>&#34;dodo&#34;</span><span class=p>,</span> <span class=s>&#34;dog&#34;</span><span class=p>,</span> <span class=s>&#34;hermit crabs&#34;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find_first_of</span><span class=p>(</span><span class=n>text</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>text</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>keywords</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>keywords</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>text</span><span class=p>.</span><span class=n>end</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;The first interesting animal we&#39;re talking about in this text is &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>it</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;.&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;The author didn&#39;t seem to like animals.&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><hr><h5 id=recherche-du-premier-√©l√©ment-v√©rifiant-un-pr√©dicat>Recherche du premier √©l√©ment v√©rifiant un pr√©dicat</h5><p>C&rsquo;est bien beau tout √ßa, mais comment faire pour r√©cup√©rer le premier √©l√©ment pair dans un tableau ?
Vous n&rsquo;allez pas pouvoir utiliser <code>find_first_of</code>, puisqu&rsquo;il faudrait que la deuxi√®me plage contienne une infinit√© d&rsquo;√©l√©ments.</p><p>Heureusement, il y a <code>find_if</code>. Comme toutes les fonctions de <code>&lt;algorithm></code> (ou presque), <code>find_if</code> attend d√©j√† les deux it√©rateurs bornant la plage d&rsquo;√©l√©ments.<br>Ensuite, vous devez lui fournir un <strong>foncteur</strong> acceptant un unique param√®tre du type des √©l√©ments de la plage (par valeur ou const-ref), et renvoyant un bool√©en.</p><p>Un foncteur, c&rsquo;est soit une fonction libre, soit une instance de classe avec un <code>operator()</code>, soit une lambda.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Fonction libre
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=nf>is_even</span><span class=p>(</span><span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>value</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find_if</span><span class=p>(</span><span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>is_even</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Objet-fonction
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>IsEven</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>operator</span><span class=p>()(</span><span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>value</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>IsEven</span> <span class=n>is_even_obj</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find_if</span><span class=p>(</span><span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>is_even_obj</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Lambda
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find_if</span><span class=p>(</span><span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=p>[](</span><span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>value</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>;</span> <span class=p>});</span></span></span></code></pre></div><div class="box notices cstyle tip"><div class=box-label><i class="fa-fw fas fa-lightbulb"></i> Astuce</div><div class=box-content><p>On d√©signe par <strong>pr√©dicats</strong> les foncteurs retournant un bool√©en. En fonction du nombre de param√®tres accept√©s, on parlera de pr√©dicat unaire, binaire, ternaire, etc.</p></div></div><p>Sachez qu&rsquo;il existe aussi <code>find_if_not</code> pour r√©cup√©rer le premier √©l√©ment qui ne ne v√©rifie pas un pr√©dicat.<br>Il est int√©ressant de s&rsquo;en servir lorsque vous avez d√©j√† une fonction libre ou un objet-fonction v√©rifiant l&rsquo;inverse de ce que vous recherchez.<br>Utiliser <code>find_if_not</code> √©vite alors d&rsquo;√©crire une nouvelle fonction ou une nouvelle classe.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>is_even</span><span class=p>(</span><span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>value</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>first_odd_it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find_if_not</span><span class=p>(</span><span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>is_even</span><span class=p>);</span></span></span></code></pre></div><hr><h3 id=v√©rification-globale-de-pr√©dicats>V√©rification globale de pr√©dicats</h3><p>Lorsque l&rsquo;on veut savoir si un pr√©dicat est v√©rifi√© par l&rsquo;ensemble des √©l√©ments d&rsquo;une plage, on peut utiliser <code>std::all_of</code>, dans <code>&lt;algorithm></code>.
On a √©galement <code>std::any_of</code> et <code>std::none_of</code>, permettant respectivement de savoir si au moins un √©l√©ment v√©rifie le pr√©dicat, ou si aucun √©l√©ment ne v√©rifie le pr√©dicat.</p><div class="box notices cstyle note"><div class=box-label><i class="fa-fw fas fa-exclamation-circle"></i> Remarque</div><div class=box-content><p>Petit rappel de logique propositionnelle : le r√©sultat de <code>none_of</code> est l&rsquo;inverse du r√©sultat de <code>any_of</code>, pas de celui de <code>all_of</code>.</p></div></div><p>Comme <code>find_if</code>, ces trois fonctions attendent deux it√©rateurs et un pr√©dicat. Elles retournent par contre un bool√©en.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>is_even</span><span class=p>(</span><span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>value</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>it_begin</span> <span class=o>=</span> <span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>it_end</span> <span class=o>=</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>all_of</span><span class=p>(</span><span class=n>it_begin</span><span class=p>,</span> <span class=n>it_end</span><span class=p>,</span> <span class=n>is_even</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;All values are even!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>none_of</span><span class=p>(</span><span class=n>it_begin</span><span class=p>,</span> <span class=n>it_end</span><span class=p>,</span> <span class=n>is_even</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Pour avoir l&#39;inverse d&#39;un pr√©dicat, on peut utiliser not_fn de &lt;functional&gt;. 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>all_of</span><span class=p>(</span><span class=n>it_begin</span><span class=p>,</span> <span class=n>it_end</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>not_fn</span><span class=p>(</span><span class=n>is_even</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;All values are odd!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>any_of</span><span class=p>(</span><span class=n>it_begin</span><span class=p>,</span> <span class=n>it_end</span><span class=p>,</span> <span class=n>is_even</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>any_of</span><span class=p>(</span><span class=n>it_begin</span><span class=p>,</span> <span class=n>it_end</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>not_fn</span><span class=p>(</span><span class=n>is_even</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Some values are even, and some are odd!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><hr><h3 id=compter-des-√©l√©ments>Compter des √©l√©ments</h3><p>Une des op√©rations courantes √† r√©aliser sur une plage de valeurs, c&rsquo;est de compter le nombre d&rsquo;occurrence d&rsquo;un √©l√©ment.
Pour cela, il y a la fonction <code>std::count</code>, encore une fois dans <code>&lt;algorithm></code>.
Il y a √©galement <code>std::count_if</code>, si vous souhaitez compter le nombre d&rsquo;√©l√©ments v√©rifiant un pr√©dicat, plut√¥t que le nombre d&rsquo;occurrences d&rsquo;un √©l√©ment pr√©cis.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>nb_1</span>    <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>count</span><span class=p>(</span><span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>nb_even</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>count_if</span><span class=p>(</span><span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>is_even</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>nb_odd</span>  <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>count_if</span><span class=p>(</span><span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>std</span><span class=o>::</span><span class=n>not_fn</span><span class=p>(</span><span class=n>is_even</span><span class=p>));</span></span></span></code></pre></div><hr><h3 id=min-et-max>Min et max</h3><h5 id=comparer-deux-√©l√©ments>Comparer deux √©l√©ments</h5><p>Vous le savez peut-√™tre d√©j√†, mais plut√¥t qu&rsquo;√©crire une ternaire pour d√©terminer le minimum ou le maximum de deux valeurs, vous pouvez utiliser les fonctions <code>std::min</code> et <code>std::max</code> (oui, toujours dans <code>&lt;algorithm></code>).
Ce que vous ne savez peut-√™tre pas, c&rsquo;est qu&rsquo;il est possible de passer un <strong>comparateur</strong> √† cette fonction.</p><p>Un comparateur, c&rsquo;est un foncteur qui accepte deux param√®tres de m√™me type, et qui renvoie un bool√©en.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Si on ne passe pas de comparateur, le compilateur essaye d&#39;utiliser operator&lt; entre value1 et value2.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=k>auto</span> <span class=n>max_value</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>value1</span><span class=p>,</span> <span class=n>value2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Comme on n&#39;a pas forc√©ment envie que Person::operator&lt; se base sur la taille, on peut passer un autre comparateur √† std::min.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=k>auto</span> <span class=n>compare_by_height</span> <span class=o>=</span> <span class=p>[](</span><span class=k>const</span> <span class=n>Person</span><span class=o>&amp;</span> <span class=n>p1</span><span class=p>,</span> <span class=k>const</span> <span class=n>Person</span><span class=o>&amp;</span> <span class=n>p2</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>p1</span><span class=p>.</span><span class=n>height</span> <span class=o>&lt;</span> <span class=n>p2</span><span class=p>.</span><span class=n>height</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>shortest_person</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>person1</span><span class=p>,</span> <span class=n>person2</span><span class=p>,</span> <span class=n>compare_by_height</span><span class=p>);</span></span></span></code></pre></div><p>Si vous n&rsquo;utilisez pas tout √† fait les m√™mes types, par exemple, en m√©langeant des <code>size_t</code> et des <code>unsigned int</code>, les appels √† <code>std::min</code> et <code>std::max</code> ne pourront pas compiler.
En effet, la fonction ne saura pas quel type utilis√© pour le r√©sultat.
Pour d√©sambiguifier la situation, il faudra donc indiquer clairement le type utilis√© avec <code>std::min&lt;T>(...)</code> ou <code>std::max&lt;T>(...)</code>.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Par d√©faut, √©crire &#34;0&#34; cr√©√© un √©l√©ment de type int, alors que values.size() et expected_size sont de type size_t.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=k>auto</span> <span class=n>new_size</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>values</span><span class=p>.</span><span class=n>size</span><span class=p>(),</span> <span class=n>expected_size</span><span class=p>);</span></span></span></code></pre></div><p>Parfois, on veut r√©cup√©rer √† la fois le minimum et le maximum. Dans ce cas l√†, plut√¥t que d&rsquo;avoir un appel √† <code>min</code> et un appel √† <code>max</code>, c&rsquo;est-√†-dire deux comparaisons, on peut utiliser la fonction <code>std::minmax</code>.
Celle-ci retourne un objet de type <code>std::pair&lt;T, T></code>, contenant le minimum pour premier √©l√©ment et le maximum pour second √©l√©ment.
Et ici aussi, plut√¥t que de faire <code>result.first</code> et <code>result.second</code> pour acc√©der au contenu de la paire, on peut utiliser un structured binding pour r√©cup√©rer le r√©sultat.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>compare_by_height</span> <span class=o>=</span> <span class=p>[](</span><span class=k>const</span> <span class=n>Person</span><span class=o>&amp;</span> <span class=n>p1</span><span class=p>,</span> <span class=k>const</span> <span class=n>Person</span><span class=o>&amp;</span> <span class=n>p2</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>p1</span><span class=p>.</span><span class=n>height</span> <span class=o>&lt;</span> <span class=n>p2</span><span class=p>.</span><span class=n>height</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=p>[</span><span class=n>shortest</span><span class=p>,</span> <span class=n>tallest</span><span class=p>]</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>minmax</span><span class=p>(</span><span class=n>person1</span><span class=p>,</span> <span class=n>person2</span><span class=p>,</span> <span class=n>compare_by_height</span><span class=p>);</span></span></span></code></pre></div><hr><h5 id=comparer-n-√©l√©ments>Comparer N √©l√©ments</h5><p>Les trois fonctions <code>std::min</code>, <code>std::max</code> et <code>std::minmax</code> disposent de surcharges acceptant une <code>initializer_list</code>.
On peut ainsi r√©cup√©rer le minimum et le maximum d&rsquo;un ensemble de valeurs.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>min_value</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>({</span> <span class=mi>0</span><span class=p>,</span> <span class=n>value1</span><span class=p>,</span> <span class=n>value2</span><span class=p>,</span> <span class=n>value3</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>compare_by_height</span> <span class=o>=</span> <span class=p>[](</span><span class=k>const</span> <span class=n>Person</span><span class=o>&amp;</span> <span class=n>p1</span><span class=p>,</span> <span class=k>const</span> <span class=n>Person</span><span class=o>&amp;</span> <span class=n>p2</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>p1</span><span class=p>.</span><span class=n>height</span> <span class=o>&lt;</span> <span class=n>p2</span><span class=p>.</span><span class=n>height</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=p>[</span><span class=n>shortest</span><span class=p>,</span> <span class=n>tallest</span><span class=p>]</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>minmax</span><span class=p>({</span> <span class=n>person1</span><span class=p>,</span> <span class=n>person2</span><span class=p>,</span> <span class=n>person3</span> <span class=p>},</span> <span class=n>compare_by_height</span><span class=p>);</span></span></span></code></pre></div><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Information</div><div class=box-content><p>Attention cependant, en passant des √©l√©ments par <code>initializer_list</code>, ces √©l√©ments sont forc√©ment copi√©s.
Dans le code plus haut, cela signifie que <code>shortest</code> est un nouvel objet, et non pas une r√©f√©rence sur l&rsquo;un des objets <code>person#</code>.
Si vous voulez vraiment r√©cup√©rer des r√©f√©rences, vous pouvez cr√©er des r√©f√©rences wrappers √† la vol√©e, avec l&rsquo;appel suivant :<br><code>const auto [shortest, tallest] = std::minmax&lt;const Person&>({ std::cref(person1), std::cref(person2), std::cref(person3) }, compare_by_height };</code></p></div></div><hr><h5 id=comparer-les-√©l√©ments-dune-plage>Comparer les √©l√©ments d&rsquo;une plage</h5><p>Il n&rsquo;est pas possible de cr√©er des <code>initializer_list</code> √† partir d&rsquo;un autre conteneur.</p><p>Du coup, si l&rsquo;on veut r√©cup√©rer l&rsquo;√©l√©ment minimum dans un <code>vector</code>, <code>&lt;algorithm></code> fournit la fonction <code>std::min_element</code>.
On retrouve bien s√ªr aussi <code>std::max_element</code> et <code>std::minmax_element</code>.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>min_value</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min_element</span><span class=p>(</span><span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>compare_by_height</span> <span class=o>=</span> <span class=p>[](</span><span class=k>const</span> <span class=n>Person</span><span class=o>&amp;</span> <span class=n>p1</span><span class=p>,</span> <span class=k>const</span> <span class=n>Person</span><span class=o>&amp;</span> <span class=n>p2</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>p1</span><span class=p>.</span><span class=n>height</span> <span class=o>&lt;</span> <span class=n>p2</span><span class=p>.</span><span class=n>height</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=p>[</span><span class=n>shortest</span><span class=p>,</span> <span class=n>tallest</span><span class=p>]</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>minmax_element</span><span class=p>(</span><span class=n>persons</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>persons</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>compare_by_height</span><span class=p>);</span></span></span></code></pre></div><hr><h5 id=bornes-inf√©rieure-et-sup√©rieure>Bornes inf√©rieure et sup√©rieure</h5><p>Dans une plage d&rsquo;√©l√©ments tri√©e en selon un ordre donn√©, il est possible d&rsquo;extraire le premier √©l√©ment √† √™tre sup√©rieur ou √©gal (par rapport √† l&rsquo;ordre choisi pour le conteneur) √† une valeur donn√©e.
Par exemple, si on a [0, 3, 5, 6, 8, 10], alors le premier √©l√©ment sup√©rieur ou √©gal √† 5 est 5, et le premier √©l√©ment sup√©rieur ou √©gal √† 2 est 3.</p><p>La fonction <code>std::lower_bound</code> permet de r√©cup√©rer cet √©l√©ment :</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>values</span> <span class=p>{</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>10</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>lower_bound</span><span class=p>(</span><span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=mi>2</span><span class=p>);</span> <span class=c1>// *it should be 3.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>names</span> <span class=p>{</span> <span class=s>&#34;Johnny halliday&#34;</span><span class=p>,</span> <span class=s>&#34;Jack L&#39;Eventreur&#34;</span><span class=p>,</span> <span class=s>&#34;Denver Le Dernier Dinosaure&#34;</span><span class=p>,</span> <span class=s>&#34;Anne hidalgo&#34;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// Si la plage n&#39;est pas ordonn√©e selon operator&lt;, on doit passer √† lower_bound un comparateur respectant l&#39;ordre de la plage.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>lower_bound</span><span class=p>(</span><span class=n>names</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>names</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=s>&#34;Ji&#34;</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>greater</span> <span class=p>{});</span> <span class=c1>// *it should be &#34;Jack L&#39;Eventreur&#34;
</span></span></span></code></pre></div><p>Si on veut maintenant r√©cup√©rer le dernier √©l√©ment inf√©rieur ou √©gal √† une valeur, on peut utiliser <code>upper_bound</code> :</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>values</span> <span class=p>{</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>10</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>upper_bound</span><span class=p>(</span><span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=mi>2</span><span class=p>);</span> <span class=c1>// *it should be 0.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>names</span> <span class=p>{</span> <span class=s>&#34;Johnny Halliday&#34;</span><span class=p>,</span> <span class=s>&#34;Jack L&#39;Eventreur&#34;</span><span class=p>,</span> <span class=s>&#34;Denver Le Dernier Dinosaure&#34;</span><span class=p>,</span> <span class=s>&#34;Anne hidalgo&#34;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>upper_bound</span><span class=p>(</span><span class=n>names</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>names</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=s>&#34;Ji&#34;</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>greater</span> <span class=p>{});</span> <span class=c1>// *it should be &#34;Johnny Halliday&#34;
</span></span></span></code></pre></div><div class="box notices cstyle info"><div class=box-label><i class="fa-fw fas fa-info-circle"></i> Information</div><div class=box-content><p>Assurez-vous bien que votre plage d&rsquo;√©l√©ments soit tri√©e lorsque vous utilisez <code>std::lower_bound</code> ou <code>std::upper_bound</code>.</p></div></div><hr><h3 id=comparaison-de-plages>Comparaison de plages</h3><p>Nous allons maintenant vous pr√©senter quelques fonctions (faisant toutes partie de <code>&lt;algorithm></code>) permettant de comparer des plages d&rsquo;√©l√©ments entre elles.</p><hr><h5 id=egalit√©-ou-√©quivalence>Egalit√© ou √©quivalence</h5><p>Pour commencer, pour savoir si deux plages d&rsquo;√©l√©ments sont √©gales, vous pouvez utiliser <code>std::equal</code>.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>begin</span> <span class=o>=</span> <span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>end</span> <span class=o>=</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>half</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>next</span><span class=p>(</span><span class=n>begin</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>distance</span><span class=p>(</span><span class=n>begin</span><span class=p>,</span> <span class=n>end</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>equals</span><span class=p>(</span><span class=n>begin</span><span class=p>,</span> <span class=n>half</span><span class=p>,</span> <span class=n>half</span><span class=p>,</span> <span class=n>end</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;The first half of values contains the same elements as its second half.&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>equals</span><span class=p>(</span><span class=n>my_dogs_names</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>my_dogs_names</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>your_dogs_names</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>your_dogs_names</span><span class=p>.</span><span class=n>end</span><span class=p>()))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Stop calling your dogs the same way I do!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Vous pouvez passer un comparateur √† la fonction, en particulier si vous ne traitez pas des plages du m√™me type.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Dog</span><span class=o>&gt;</span> <span class=n>dogs</span> <span class=p>{</span> <span class=n>Dog</span> <span class=p>{</span> <span class=s>&#34;medor&#34;</span> <span class=p>},</span> <span class=n>Dog</span> <span class=p>{</span> <span class=s>&#34;dagobert&#34;</span> <span class=p>},</span> <span class=n>Dog</span> <span class=p>{</span> <span class=s>&#34;nonoss&#34;</span> <span class=p>}</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Cat</span><span class=o>&gt;</span> <span class=n>cats</span> <span class=p>{</span> <span class=n>Cat</span> <span class=p>{</span> <span class=s>&#34;medor&#34;</span> <span class=p>},</span> <span class=n>Cat</span> <span class=p>{</span> <span class=s>&#34;dagobert&#34;</span> <span class=p>},</span> <span class=n>Cat</span> <span class=p>{</span> <span class=s>&#34;nonoss&#34;</span> <span class=p>}</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>compare_names</span> <span class=o>=</span> <span class=p>[](</span><span class=k>const</span> <span class=n>Dog</span><span class=o>&amp;</span> <span class=n>dog</span><span class=p>,</span> <span class=k>const</span> <span class=n>Cat</span><span class=o>&amp;</span> <span class=n>cat</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>dog</span><span class=p>.</span><span class=n>name</span><span class=p>()</span> <span class=o>==</span> <span class=n>cat</span><span class=p>.</span><span class=n>name</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>equals</span><span class=p>(</span><span class=n>dogs</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>dogs</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>cats</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>cats</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>compare_names</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Why would you ever name your cats this way?&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Enfin, il est possible de v√©rifier si deux plages contiennent les m√™mes √©l√©ments, mais pas forc√©ment dans le m√™me ordre, en utilisant <code>std::is_permutation</code>.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>unsigned</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>my_numbers</span> <span class=p>{</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>33</span><span class=p>,</span> <span class=mi>21</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>unsigned</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>winning_numbers</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>21</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>33</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>is_permutation</span><span class=p>(</span><span class=n>my_numbers</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>my_numbers</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>winning_numbers</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>winning_numbers</span><span class=p>.</span><span class=n>end</span><span class=p>()))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;WOUHHHHHH OOOOOOOOOOOOOOUUUUUUUUHHHHHHHHHH!!!!!!!!!!!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><div class="box notices cstyle note"><div class=box-label><i class="fa-fw fas fa-exclamation-circle"></i> Remarque</div><div class=box-content><p>Il est possible de passer un comparateur √† <code>equals</code>, et c&rsquo;est √©galement possible de le faire avec <code>is_permutation</code>, ainsi qu&rsquo;avec toutes les autres fonctions pr√©sent√©es dans cette section.</p></div></div><hr><h5 id=comparaison-lexicographique>Comparaison lexicographique</h5><p>Comparer lexicographiquement deux cha√Ænes de caract√®res revient √† d&rsquo;abord comparer les premi√®res lettres, puis si elles sont √©gales, les deuxi√®mes, puis si elles sont √©gales aussi, les troisi√®mes, et ainsi de suite jusqu&rsquo;√† trouver deux lettres qui ne sont pas identique.</p><p>Ce proc√©d√© peut se g√©n√©raliser √† n&rsquo;importe quels types de plages d&rsquo;√©l√©ments en utilisant la fonction <code>std::lexicographical_compare</code>.</p><div class="highlight wrap-code"><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=n>Pokemon</span><span class=p>,</span> <span class=mi>6</span><span class=o>&gt;</span> <span class=n>my_pokemons</span> <span class=p>{</span> <span class=p>...</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>array</span><span class=o>&lt;</span><span class=n>Pokemon</span><span class=p>,</span> <span class=mi>6</span><span class=o>&gt;</span> <span class=n>your_pokemons</span> <span class=p>{</span> <span class=p>...</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>lexicographical_compare</span><span class=p>(</span><span class=n>my_pokemons</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>my_pokemons</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>your_pokemons</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>your_pokemons</span><span class=p>.</span><span class=n>end</span><span class=p>()))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;You win the duel.&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;I win the duel.&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><footer class=footline></footer></article></div></main></div><aside id=R-sidebar class="default-animation showVisitedLinks"><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=logo href=../../>üéÑ C++ üéÑ</a></div></div><div id=R-homelinks class=default-animation><hr class=padding></div><div id=R-content-wrapper class=highlightable><div id=R-topics><ul class="enlarge morespace collapsible-menu"><li data-nav-id=/chapter0/index.html><a class=padding href=../../chapter0/index.html><b>0- </b>Mise en place<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-bb41caf94f12b8a1a4b5e560230e7851 class=collapsible-menu></ul></li><li data-nav-id=/chapter1/index.html><a class=padding href=../../chapter1/index.html><b>1- </b>Introduction au C++<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-6c398714eae4372920aec3a1e6c2e143 class=collapsible-menu></ul></li><li data-nav-id=/chapter2/index.html><a class=padding href=../../chapter2/index.html><b>2- </b>Classes<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-b1df0095a9fd74320697a6d478418ec3 class=collapsible-menu></ul></li><li data-nav-id=/chapter3/index.html><a class=padding href=../../chapter3/index.html><b>3- </b>Cycle de vie<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-9f6546bce6f8e9a77063b71c880fd5b8 class=collapsible-menu></ul></li><li data-nav-id=/chapter4/index.html><a class=padding href=../../chapter4/index.html><b>4- </b>H√©ritage<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-48065e8b6e7e69533ca73b3931c8a0a1 class=collapsible-menu></ul></li><li data-nav-id=/chapter5/index.html><a class=padding href=../../chapter5/index.html><b>5- </b>Librairie standard<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-86528e6ba587b53932a1dafaa9cd375c class=collapsible-menu></ul></li><li class=parent data-nav-id=/chapter6/index.html><a class=padding href=../../chapter6/index.html><b>6- </b>Algorithmes<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-016ee40825ff7c4aeecbac08a8ca264b class=collapsible-menu><li class=active data-nav-id=/chapter6/1-searches/index.html><a class=padding href=../../chapter6/1-searches/index.html>Parcours et recherches<i class="fa-fw fas fa-check read-icon"></i></a></li><li data-nav-id=/chapter6/2-transformations/index.html><a class=padding href=../../chapter6/2-transformations/index.html>Transformations<i class="fa-fw fas fa-check read-icon"></i></a></li><li data-nav-id=/chapter6/3-iterators/index.html><a class=padding href=../../chapter6/3-iterators/index.html>It√©rateurs<i class="fa-fw fas fa-check read-icon"></i></a></li><li data-nav-id=/chapter6/4-lambdas/index.html><a class=padding href=../../chapter6/4-lambdas/index.html>Lambdas<i class="fa-fw fas fa-check read-icon"></i></a></li><li data-nav-id=/chapter6/test/index.html><a class=padding href=../../chapter6/test/index.html>Questionnaire ‚òë<i class="fa-fw fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/chapter9/index.html><a class=padding href=../../chapter9/index.html><b>7- </b>Templates<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-24ddf636ccd0ce3ef39c8060d1779332 class=collapsible-menu></ul></li><li data-nav-id=/chapter10/index.html><a class=padding href=../../chapter10/index.html><b>8- </b>Param√®tres de templates<i class="fa-fw fas fa-check read-icon"></i></a><ul id=R-subsections-66e6e0c58d73995ecc09e8fbbe358e51 class=collapsible-menu></ul></li></ul></div><div id=R-shortcuts><div class="nav-title padding">Acc√®s rapide</div><ul class=space><li><a class=padding href=https://github.com/Laefy/CPP_Learning_Code/><i class='fab fa-github'></i> D√©p√¥t Cours</a></li><li><a class=padding href=https://github.com/Laefy/CPP_Exercises/><i class='fab fa-github'></i> D√©p√¥t TPs</a></li><li><a class=padding href=../../slides/index.html><i class='far fa-file-powerpoint'></i> Slides</a></li><li><a class=padding href=../../workflow/index.html><i class='far fa-list-alt'></i> Workflow</a></li><li><a class=padding href=../../faq/index.html><i class='fas fa-question-circle'></i> FAQ</a></li><li><a class=padding href=../../chapter0/6-tips/index.html><i class='fa fa-rocket'></i> Astuces</a></li><li><a class=padding href=https://godbolt.org/><i class='fas fa-cog'></i> Compiler Explorer</a></li><li><a class=padding href=https://en.cppreference.com/w/><i class='fas fa-passport'></i> CPP-Ref</a></li></ul></div><div class="padding footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVisitedLinks showFooter"></div><div id=R-menu-footer><hr class="padding default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVisitedLinks showFooter"><div id=R-prefooter class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVisitedLinks"><ul><li id=R-select-language-container class=footerLangSwitch><div class="padding menu-control"><i class="fa-fw fas fa-language"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-language>Langue</label>
<select id=R-select-language onchange="location=this.querySelector(this.value).dataset.url"><option id=R-select-language-fr value=#R-select-language-fr data-url=../../chapter6/1-searches/index.html lang=fr selected>Fran√ßais</option></select></div><div class=clear></div></div></li><li id=R-select-variant-container class=footerVariantSwitch><div class="padding menu-control"><i class="fa-fw fas fa-paint-brush"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-variant>Th√®me</label>
<select id=R-select-variant onchange=window.variants&&variants.changeVariant(this.value)><option id=R-select-variant-mine value=mine selected>Mine</option></select></div><div class=clear></div></div><script>window.variants&&variants.markSelectedVariant()</script></li><li class="footerVisitedLinks showVisitedLinks"><div class="padding menu-control"><i class="fa-fw fas fa-history"></i>
<span>&nbsp;</span><div class=control-style><button onclick=clearHistory()>Supprimer l'historique</button></div><div class=clear></div></div></li></ul></div><div id=R-footer class="footerFooter showFooter"><p>Built with <a href=https://github.com/McShelby/hugo-theme-relearn title=love><i class="fas fa-heart"></i></a> by <a href=https://gohugo.io/>Hugo</a></p></div></div></div></aside><script src=../../js/clipboard.min.js?1729268528 defer></script><script src=../../js/perfect-scrollbar.min.js?1729268528 defer></script><script src=../../js/theme.js?1729268528 defer></script><button id=footer-question-btn title="Envoyer un message √† propos du texte s√©lectionn√©" onclick=openQuestionForm() disabled><i class="fas fa-question-circle"></i></button><div id=footer-question-window disabled><form id=question method=POST action=https://formsubmit.co/3aa0f379a1aed9c454634cc2da153a7b target=question-submitted onsubmit=cleanQuestionFormContent()><input type=email name=email placeholder=mon_email@smthg.com required onchange=updateQuestionFormSubject()>
<textarea name=question rows=7 cols=30 placeholder="Mon message..."></textarea>
<input type=hidden name=selection>
<input type=hidden name=_replyto>
<input type=hidden name=_subject>
<input type=hidden name=_template value=box>
<input type=hidden name=_captcha value=false>
<input type=hidden name=_next value=//question-submitted/>
<input type=submit disabled style=display:none aria-hidden=true>
<input type=submit value=Envoyer></form><iframe class=hidden name=question-submitted src></iframe></div><script>function updateQuestionFormSubject(){let e=document.querySelector('#question>input[name="email"]').value;document.querySelector('#question>input[name="_subject"]').value="[C++][Chapitre 6] "+e+", retour sur ta question"}function cleanQuestionFormContent(){function e(e){e.value=e.value.replace(/\[\.\./g,"[ ..")}e(document.querySelector('#question>textarea[name="question"]')),e(document.querySelector('#question>input[name="selection"]'))}function openQuestionForm(){document.getElementById("footer-question-window").removeAttribute("disabled");var e=window.getSelection().toString();document.querySelector('#question>input[name="selection"]').value=e}function updateQuestionWidgetState(e){var t=document.getElementById("R-body-inner"),n=window.getSelection(),s=document.getElementById("footer-question-window");document.getElementById("footer-question-btn").disabled=n.isCollapsed||t==null||t.contains(n.anchorNode)==!1||t.contains(n.focusNode)==!1,e!==void 0&&e.type=="mouseup"&&s.contains(e.target)==!1&&s.contains(document.activeElement)==!1&&s.setAttribute("disabled",!0)}updateQuestionFormSubject(),document.onmouseup=document.onkeyup=document.onselectionchange=updateQuestionWidgetState,updateQuestionWidgetState()</script></body></html>