<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithmes :: Cours de C&#43;&#43; - Niveau Master</title>
    <link>/chapter6/index.html</link>
    <description>Comme vous le savez dÃ©jÃ , la STL fournit tout un tas de conteneurs pour rÃ©pondre Ã  diffÃ©rents usages. Ces conteneurs proposent des fonctions permettant lâ€™insertion et la suppression dâ€™Ã©lÃ©ments, mais rarement de quoi effectuer des recherches ou des transformations. Le but de ce chapitre sera donc de vous prÃ©senter comment faire pour rÃ©aliser ces opÃ©rations, notamment en sâ€™appuyant sur la bibliothÃ¨que algorithmique fournie par la librairie standard.&#xA;Nous ne prÃ©senterons pas lâ€™ensemble des fonctions de la librairie (il y en a beaucoup trop), mais si cela vous intÃ©resse, vous pourrez retrouver tout ce quâ€™elle propose sur cette page.</description>
    <generator>Hugo</generator>
    <language>fr</language>
    <atom:link href="/chapter6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Parcours et recherches</title>
      <link>/chapter6/1-searches/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/chapter6/1-searches/index.html</guid>
      <description>Parcours de plages Pour parcourir une plage dâ€™Ã©lÃ©ments, vous devriez normalement dÃ©jÃ  savoir quâ€™il faut utiliser une boucle for ou foreach. Les boucles while et do-while ne sont en effet pas vraiment adaptÃ©es Ã  ce type dâ€™usage.&#xA;Vous trouverez quelques conseils dans cette partie pour rendre votre code plus lisible, concis et fiable.&#xA;Boucle foreach Lorsquâ€™on itÃ¨re sur un conteneur avec une boucle foreach, il faut faire attention Ã  si lâ€™on souhaite rÃ©cupÃ©rer une copie de lâ€™Ã©lÃ©ment ou une rÃ©fÃ©rence.</description>
    </item>
    <item>
      <title>Transformations</title>
      <link>/chapter6/2-transformations/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/chapter6/2-transformations/index.html</guid>
      <description>Maintenant que nous vous avons prÃ©sentÃ© les fonctions permettant de rÃ©cupÃ©rer des informations Ã  partir dâ€™une plage dâ€™Ã©lÃ©ments, nous allons vous prÃ©senter celles qui permettent de manipuler et de transformer ces plages.&#xA;Suppressions Afin de supprimer des Ã©lÃ©ments dâ€™une plage, on utilise la fonction std::remove. Cette fonction a pour effet de dÃ©placer les Ã©lÃ©ments Ã  conserver au dÃ©but de la plage, en prÃ©servant leur ordre. Elle renvoie un itÃ©rateur sur le nouvel itÃ©rateur de fin de plage.</description>
    </item>
    <item>
      <title>ItÃ©rateurs</title>
      <link>/chapter6/3-iterators/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/chapter6/3-iterators/index.html</guid>
      <description>Normalement, avec tout ce que vous avez vu jusquâ€™ici, vous devriez Ãªtre capable dâ€™utiliser correctement un itÃ©rateur :&#xA;dÃ©rÃ©fÃ©rencement avec *it incrÃ©mentation avec ++it rÃ©cupÃ©rer les itÃ©rateurs de dÃ©but et de fin dâ€™un conteneur avec ctn.begin() et ctn.end() insÃ©rer un Ã©lÃ©ment dans un conteneur avec auto it_on_new = ctn.insert(it, new_value) supprimer un Ã©lÃ©ment dâ€™un conteneur avec auto it_on_next = ctn.erase(it) Vous allez maintenant voir ce quâ€™il faut faire pour implÃ©menter vos propres itÃ©rateurs.</description>
    </item>
    <item>
      <title>Lambdas</title>
      <link>/chapter6/4-lambdas/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/chapter6/4-lambdas/index.html</guid>
      <description>Les lambdas sont des objets-fonction un peu spÃ©ciaux, que lâ€™on peut facilement dÃ©finir depuis le corps dâ€™une fonction. Vous avez dÃ©jÃ  dÃ» voir de nombreux exemples dâ€™utilisation de lambda tout au long de ce cours. Nous allons maintenant revenir plus en dÃ©tail sur leur fonctionnement et vous montrez tout ce quâ€™il est possible de faire avec.&#xA;Syntaxe La dÃ©finition dâ€™une lambda est composÃ©e en gÃ©nÃ©ral de trois parties :&#xA;[c1, c2, c3](int p1, int p2, int p3) { return c1 * p1 + c2 * p2 + c3 * p3; } La partie entre crochet sâ€™appelle la capture.</description>
    </item>
    <item>
      <title>Questionnaire â˜‘</title>
      <link>/chapter6/test/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/chapter6/test/index.html</guid>
      <description>Câ€™est lâ€™heure du test ! Nâ€™oubliez pas que vous pouvez utiliser Godbolt pour compiler et tester des petits bouts de code.&#xA;Bon courage Ã  vous ğŸ™‚&#xA;Vous Ãªtes : Votre adresse mail : Votre groupe : Initiaux 1 Initiaux 2 Alternants 1- Quel type de boucle faut-il utiliser pour modifier la structure dâ€™un conteneur lors dâ€™un parcours ?&#xA;2- Dans quel cas peut-il Ãªtre intÃ©ressant dâ€™utiliser la fonction std::for_each ?</description>
    </item>
    <item>
      <title>Merci !</title>
      <link>/chapter6/test_done/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/chapter6/test_done/index.html</guid>
      <description>Vos rÃ©ponses nous ont bien Ã©tÃ© communiquÃ©es ğŸ˜ƒ N&#39;hÃ©sitez pas Ã  nous relancer si vous n&#39;avez pas eu de nouvelles aprÃ¨s une semaine !</description>
    </item>
  </channel>
</rss>