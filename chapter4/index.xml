<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HÃ©ritage :: Cours de C&#43;&#43; - Niveau Master</title>
    <link>/chapter4/index.html</link>
    <description>Vous apprendrez dans ce chapitre comment fonctionne lâ€™hÃ©ritage en C++. Vous verrez quâ€™il existe de nombreuses diffÃ©rences avec lâ€™hÃ©ritage en Java, bien quâ€™on retrouve des concepts similaires.&#xA;Pour la pratique, nous vous montrerons comment crÃ©er une hiÃ©rarchie de classes, puis comment faire pour redÃ©finir le comportement des classes-filles.</description>
    <generator>Hugo</generator>
    <language>fr</language>
    <atom:link href="/chapter4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ğŸ’¼ HiÃ©rarchie professionnelle</title>
      <link>/chapter4/1-hierarchy/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/chapter4/1-hierarchy/index.html</guid>
      <description>Dans cette premiÃ¨re partie, vous apprendrez comment dÃ©finir des relations de parentÃ© entre vos classes.&#xA;Nous ne parlerons sur cette page que dâ€™hÃ©ritage dit â€œstatiqueâ€, câ€™est-Ã -dire que nous ne chercherons pas Ã  modifier dans les classes-fille le comportement hÃ©ritÃ© de la classe-mÃ¨re.&#xA;Pour cet exercice, vous modifierez les fichiers :&#xA;- chap-04/1-hierarchy/Boss.cpp&#xA;- chap-04/1-hierarchy/Boss.h&#xA;- chap-04/1-hierarchy/Staff.cpp&#xA;- chap-04/1-hierarchy/Staff.h&#xA;- chap-04/1-hierarchy/Intern.cpp&#xA;- chap-04/1-hierarchy/Intern.h&#xA;La cible Ã  compiler est c4-1-hierarchy.&#xA;DÃ©finir une classe-mÃ¨re Commencez par jeter un coup dâ€™oeil Ã  chacun des fichiers fournis.</description>
    </item>
    <item>
      <title>ğŸ® Concerto animalier</title>
      <link>/chapter4/2-farm/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/chapter4/2-farm/index.html</guid>
      <description>Vous allez maintenant apprendre Ã  dÃ©finir des classes permettant Ã  leurs enfants de spÃ©cialiser leur comportement. On parle alors de classe polymorphe.&#xA;Nous ferons un petit rÃ©capitulatif en fin de page, pour rappelez les points essentiels auxquels il faut faire attention lorsque vous dÃ©finissez des classes polymorphes pour Ã©viter les bugs.&#xA;Pour cet exercice, vous modifierez les fichiers :&#xA;- chap-04/2-farm/FarmHouse.cpp&#xA;- chap-04/2-farm/Animal.h&#xA;- chap-04/2-farm/Dog.h&#xA;- chap-04/2-farm/Cat.h&#xA;- chap-04/2-farm/Chicken.h&#xA;- chap-04/2-farm/Cow.</description>
    </item>
    <item>
      <title>RÃ©solution d&#39;appel virtuel</title>
      <link>/chapter4/3-virtual/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/chapter4/3-virtual/index.html</guid>
      <description>Nous allons maintenant rentrer dans les dÃ©tails de ce quâ€™il se passe sous le manteau, lorsque le programme effectue un appel virtuel.&#xA;Virtual table Lorsquâ€™une classe Parent contenant des fonctions virtuelles est compilÃ©e, le compilateur va gÃ©nÃ©rer pour lâ€™ensemble des classes qui en dÃ©rivent une virtual table. Il sâ€™agit dâ€™une tableau qui contient, pour chaque fonction virtuelle de la classe, un pointeur sur la fonction qui sera vraiment appelÃ©e.&#xA;Analysons la hiÃ©rarchie suivante :</description>
    </item>
    <item>
      <title>Polymorphisme</title>
      <link>/chapter4/4-polymorphism/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/chapter4/4-polymorphism/index.html</guid>
      <description>Vous avez probablement dÃ©jÃ  entendu le terme polymorphisme, vous lâ€™avez peut-Ãªtre mÃªme dÃ©jÃ  utilisÃ©, mais quand vous y rÃ©flÃ©chissez, si on vous demandait de le dÃ©finir clairement, vous ne sauriez pas forcÃ©ment quoi rÃ©pondre. Cette page sera donc lâ€™occasion de revenir sur sa dÃ©finition.&#xA;Dans ce chapitre, nous nous sommes intÃ©ressÃ©s Ã  deux maniÃ¨res de mettre-en-ouvre le polymorphisme en C++ : lâ€™hÃ©ritage statique et lâ€™hÃ©ritage dynamique. Nous dÃ©taillerons les diffÃ©rences entre les deux et dans quels cas utiliser lâ€™un ou lâ€™autre.</description>
    </item>
    <item>
      <title>ğŸš— VÃ©hicule partagÃ©</title>
      <link>/chapter4/5-vehicles/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/chapter4/5-vehicles/index.html</guid>
      <description>Pour terminer ce chapitre, nous allons voir comment faire pour accÃ©der directement aux attributs de votre classe de base, comment appeler la fonction parent depuis la rÃ©dÃ©finition de cette fonction dans la classe-fille et enfin, comment modÃ©liser des classes abstraites.&#xA;Pour cet exercice, vous modifierez les fichiers :&#xA;- chap-04/3-vehicles/Program.cpp&#xA;- chap-04/3-vehicles/Vehicle.h&#xA;- chap-04/3-vehicles/Car.h&#xA;- chap-04/3-vehicles/Scooter.h&#xA;La cible Ã  compiler est c4-3-vehicles.&#xA;Introduction du permis Dans le programme que lâ€™on vous fournit, nâ€™importe qui peut conduire nâ€™importe quoi.</description>
    </item>
    <item>
      <title>Questionnaire !</title>
      <link>/chapter4/test/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/chapter4/test/index.html</guid>
      <description>Vous avez terminÃ© le Chapitre 4 ! Câ€™est donc maintenant le moment de connecter vos neurones pour rÃ©pondre aux questions suivantes.&#xA;Bon courage Ã  vous ğŸ™‚&#xA;Vous Ãªtes : Votre adresse mail : Votre groupe : Initiaux 1 Initiaux 2 Alternants 1- Quâ€™est-ce quâ€™une classe polymorphe ?&#xA;2- DÃ©finissez une classe polymorphe Nothing qui ne fait rien.&#xA;3- Comment reprÃ©senter une classe abstraite en C++ ?&#xA;Les questions 4 Ã  6 font rÃ©fÃ©rence au code suivant :</description>
    </item>
    <item>
      <title>SynthÃ¨se</title>
      <link>/chapter4/summary/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/chapter4/summary/index.html</guid>
      <description>Ce quâ€™il faut savoir faire Langage DÃ©finir une relation de parentÃ© publique entre deux classes : class Child : public Parent { ... }; DÃ©finir un membre (fonction ou attribut) accessible uniquement depuis la classe courante et ses enfants : protected : int _a1 = 0; char _a2 = &#39;a&#39;; Appeler le constructeur de la classe parent : Child(int p1, int p2) : Parent { p1 }, _p2 { p2 } { .</description>
    </item>
    <item>
      <title>Merci !</title>
      <link>/chapter4/test_done/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/chapter4/test_done/index.html</guid>
      <description>Vos rÃ©ponses nous ont bien Ã©tÃ© communiquÃ©es ğŸ˜ƒ N&#39;hÃ©sitez pas Ã  nous relancer si vous n&#39;avez pas eu de nouvelles aprÃ¨s une semaine !</description>
    </item>
  </channel>
</rss>